{"character": "i", "row": 0, "column": 0}
{"character": "m", "row": 0, "column": 1}
{"character": "p", "row": 0, "column": 2}
{"character": "o", "row": 0, "column": 3}
{"character": "r", "row": 0, "column": 4}
{"character": "t", "row": 0, "column": 5}
{"character": " ", "row": 0, "column": 6}
{"character": "M", "row": 0, "column": 7}
{"character": "a", "row": 0, "column": 8}
{"character": "t", "row": 0, "column": 9}
{"character": "h", "row": 0, "column": 10}
{"character": "l", "row": 0, "column": 11}
{"character": "i", "row": 0, "column": 12}
{"character": "b", "row": 0, "column": 13}
{"character": "i", "row": 1, "column": 0}
{"character": "m", "row": 1, "column": 1}
{"character": "p", "row": 1, "column": 2}
{"character": "o", "row": 1, "column": 3}
{"character": "r", "row": 1, "column": 4}
{"character": "t", "row": 1, "column": 5}
{"character": " ", "row": 1, "column": 6}
{"character": "A", "row": 1, "column": 7}
{"character": "e", "row": 1, "column": 8}
{"character": "s", "row": 1, "column": 9}
{"character": "o", "row": 1, "column": 10}
{"character": "p", "row": 1, "column": 11}
{"character": "s", "row": 3, "column": 0, "range": {"start": {"line": 3, "character": 0}, "end": {"line": 3, "character": 26}}, "contents": {"value": "`set_option <id> <value>` sets the option `<id>` to `<value>`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `<id>` to list available options.\n\n`set_option <id> <value> in <command>` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option <id> <value> in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n", "kind": "markdown"}}
{"character": "e", "row": 3, "column": 1, "range": {"start": {"line": 3, "character": 0}, "end": {"line": 3, "character": 26}}, "contents": {"value": "`set_option <id> <value>` sets the option `<id>` to `<value>`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `<id>` to list available options.\n\n`set_option <id> <value> in <command>` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option <id> <value> in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n", "kind": "markdown"}}
{"character": "t", "row": 3, "column": 2, "range": {"start": {"line": 3, "character": 0}, "end": {"line": 3, "character": 26}}, "contents": {"value": "`set_option <id> <value>` sets the option `<id>` to `<value>`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `<id>` to list available options.\n\n`set_option <id> <value> in <command>` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option <id> <value> in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n", "kind": "markdown"}}
{"character": "_", "row": 3, "column": 3, "range": {"start": {"line": 3, "character": 0}, "end": {"line": 3, "character": 26}}, "contents": {"value": "`set_option <id> <value>` sets the option `<id>` to `<value>`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `<id>` to list available options.\n\n`set_option <id> <value> in <command>` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option <id> <value> in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n", "kind": "markdown"}}
{"character": "o", "row": 3, "column": 4, "range": {"start": {"line": 3, "character": 0}, "end": {"line": 3, "character": 26}}, "contents": {"value": "`set_option <id> <value>` sets the option `<id>` to `<value>`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `<id>` to list available options.\n\n`set_option <id> <value> in <command>` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option <id> <value> in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n", "kind": "markdown"}}
{"character": "p", "row": 3, "column": 5, "range": {"start": {"line": 3, "character": 0}, "end": {"line": 3, "character": 26}}, "contents": {"value": "`set_option <id> <value>` sets the option `<id>` to `<value>`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `<id>` to list available options.\n\n`set_option <id> <value> in <command>` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option <id> <value> in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n", "kind": "markdown"}}
{"character": "t", "row": 3, "column": 6, "range": {"start": {"line": 3, "character": 0}, "end": {"line": 3, "character": 26}}, "contents": {"value": "`set_option <id> <value>` sets the option `<id>` to `<value>`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `<id>` to list available options.\n\n`set_option <id> <value> in <command>` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option <id> <value> in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n", "kind": "markdown"}}
{"character": "i", "row": 3, "column": 7, "range": {"start": {"line": 3, "character": 0}, "end": {"line": 3, "character": 26}}, "contents": {"value": "`set_option <id> <value>` sets the option `<id>` to `<value>`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `<id>` to list available options.\n\n`set_option <id> <value> in <command>` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option <id> <value> in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n", "kind": "markdown"}}
{"character": "o", "row": 3, "column": 8, "range": {"start": {"line": 3, "character": 0}, "end": {"line": 3, "character": 26}}, "contents": {"value": "`set_option <id> <value>` sets the option `<id>` to `<value>`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `<id>` to list available options.\n\n`set_option <id> <value> in <command>` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option <id> <value> in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n", "kind": "markdown"}}
{"character": "n", "row": 3, "column": 9, "range": {"start": {"line": 3, "character": 0}, "end": {"line": 3, "character": 26}}, "contents": {"value": "`set_option <id> <value>` sets the option `<id>` to `<value>`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `<id>` to list available options.\n\n`set_option <id> <value> in <command>` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option <id> <value> in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n", "kind": "markdown"}}
{"character": " ", "row": 3, "column": 10, "range": {"start": {"line": 3, "character": 0}, "end": {"line": 3, "character": 26}}, "contents": {"value": "`set_option <id> <value>` sets the option `<id>` to `<value>`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `<id>` to list available options.\n\n`set_option <id> <value> in <command>` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option <id> <value> in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n", "kind": "markdown"}}
{"character": "m", "row": 3, "column": 11, "range": {"start": {"line": 3, "character": 11}, "end": {"line": 3, "character": 24}}, "contents": {"value": "maximum amount of heartbeats per command. A heartbeat is number of (small) memory allocations (in thousands), 0 means no limit", "kind": "markdown"}}
{"character": "a", "row": 3, "column": 12, "range": {"start": {"line": 3, "character": 11}, "end": {"line": 3, "character": 24}}, "contents": {"value": "maximum amount of heartbeats per command. A heartbeat is number of (small) memory allocations (in thousands), 0 means no limit", "kind": "markdown"}}
{"character": "x", "row": 3, "column": 13, "range": {"start": {"line": 3, "character": 11}, "end": {"line": 3, "character": 24}}, "contents": {"value": "maximum amount of heartbeats per command. A heartbeat is number of (small) memory allocations (in thousands), 0 means no limit", "kind": "markdown"}}
{"character": "H", "row": 3, "column": 14, "range": {"start": {"line": 3, "character": 11}, "end": {"line": 3, "character": 24}}, "contents": {"value": "maximum amount of heartbeats per command. A heartbeat is number of (small) memory allocations (in thousands), 0 means no limit", "kind": "markdown"}}
{"character": "e", "row": 3, "column": 15, "range": {"start": {"line": 3, "character": 11}, "end": {"line": 3, "character": 24}}, "contents": {"value": "maximum amount of heartbeats per command. A heartbeat is number of (small) memory allocations (in thousands), 0 means no limit", "kind": "markdown"}}
{"character": "a", "row": 3, "column": 16, "range": {"start": {"line": 3, "character": 11}, "end": {"line": 3, "character": 24}}, "contents": {"value": "maximum amount of heartbeats per command. A heartbeat is number of (small) memory allocations (in thousands), 0 means no limit", "kind": "markdown"}}
{"character": "r", "row": 3, "column": 17, "range": {"start": {"line": 3, "character": 11}, "end": {"line": 3, "character": 24}}, "contents": {"value": "maximum amount of heartbeats per command. A heartbeat is number of (small) memory allocations (in thousands), 0 means no limit", "kind": "markdown"}}
{"character": "t", "row": 3, "column": 18, "range": {"start": {"line": 3, "character": 11}, "end": {"line": 3, "character": 24}}, "contents": {"value": "maximum amount of heartbeats per command. A heartbeat is number of (small) memory allocations (in thousands), 0 means no limit", "kind": "markdown"}}
{"character": "b", "row": 3, "column": 19, "range": {"start": {"line": 3, "character": 11}, "end": {"line": 3, "character": 24}}, "contents": {"value": "maximum amount of heartbeats per command. A heartbeat is number of (small) memory allocations (in thousands), 0 means no limit", "kind": "markdown"}}
{"character": "e", "row": 3, "column": 20, "range": {"start": {"line": 3, "character": 11}, "end": {"line": 3, "character": 24}}, "contents": {"value": "maximum amount of heartbeats per command. A heartbeat is number of (small) memory allocations (in thousands), 0 means no limit", "kind": "markdown"}}
{"character": "a", "row": 3, "column": 21, "range": {"start": {"line": 3, "character": 11}, "end": {"line": 3, "character": 24}}, "contents": {"value": "maximum amount of heartbeats per command. A heartbeat is number of (small) memory allocations (in thousands), 0 means no limit", "kind": "markdown"}}
{"character": "t", "row": 3, "column": 22, "range": {"start": {"line": 3, "character": 11}, "end": {"line": 3, "character": 24}}, "contents": {"value": "maximum amount of heartbeats per command. A heartbeat is number of (small) memory allocations (in thousands), 0 means no limit", "kind": "markdown"}}
{"character": "s", "row": 3, "column": 23, "range": {"start": {"line": 3, "character": 11}, "end": {"line": 3, "character": 24}}, "contents": {"value": "maximum amount of heartbeats per command. A heartbeat is number of (small) memory allocations (in thousands), 0 means no limit", "kind": "markdown"}}
{"character": " ", "row": 3, "column": 24, "range": {"start": {"line": 3, "character": 0}, "end": {"line": 3, "character": 26}}, "contents": {"value": "`set_option <id> <value>` sets the option `<id>` to `<value>`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `<id>` to list available options.\n\n`set_option <id> <value> in <command>` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option <id> <value> in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n", "kind": "markdown"}}
{"character": "0", "row": 3, "column": 25, "range": {"start": {"line": 3, "character": 0}, "end": {"line": 3, "character": 26}}, "contents": {"value": "`set_option <id> <value>` sets the option `<id>` to `<value>`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `<id>` to list available options.\n\n`set_option <id> <value> in <command>` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option <id> <value> in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n", "kind": "markdown"}}
{"character": "o", "row": 5, "column": 0, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "p", "row": 5, "column": 1, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "e", "row": 5, "column": 2, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "n", "row": 5, "column": 3, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": " ", "row": 5, "column": 4, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "B", "row": 5, "column": 5, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "i", "row": 5, "column": 6, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "g", "row": 5, "column": 7, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "O", "row": 5, "column": 8, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "p", "row": 5, "column": 9, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "e", "row": 5, "column": 10, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "r", "row": 5, "column": 11, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "a", "row": 5, "column": 12, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "t", "row": 5, "column": 13, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "o", "row": 5, "column": 14, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "r", "row": 5, "column": 15, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "s", "row": 5, "column": 16, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": " ", "row": 5, "column": 17, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "R", "row": 5, "column": 18, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "e", "row": 5, "column": 19, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "a", "row": 5, "column": 20, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "l", "row": 5, "column": 21, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": " ", "row": 5, "column": 22, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "N", "row": 5, "column": 23, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "a", "row": 5, "column": 24, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "t", "row": 5, "column": 25, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": " ", "row": 5, "column": 26, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "T", "row": 5, "column": 27, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "o", "row": 5, "column": 28, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "p", "row": 5, "column": 29, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "o", "row": 5, "column": 30, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "l", "row": 5, "column": 31, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "o", "row": 5, "column": 32, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "g", "row": 5, "column": 33, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "y", "row": 5, "column": 34, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": " ", "row": 5, "column": 35, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "R", "row": 5, "column": 36, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "a", "row": 5, "column": 37, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "t", "row": 5, "column": 38, "range": {"start": {"line": 5, "character": 0}, "end": {"line": 5, "character": 39}}, "contents": {"value": "Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open <any of the open shapes above> in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ => a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" => BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n", "kind": "markdown"}}
{"character": "t", "row": 7, "column": 0}
{"character": "h", "row": 7, "column": 1}
{"character": "e", "row": 7, "column": 2}
{"character": "o", "row": 7, "column": 3}
{"character": "r", "row": 7, "column": 4}
{"character": "e", "row": 7, "column": 5}
{"character": "m", "row": 7, "column": 6}
{"character": " ", "row": 7, "column": 7}
{"character": "m", "row": 7, "column": 8, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "a", "row": 7, "column": 9, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "t", "row": 7, "column": 10, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "h", "row": 7, "column": 11, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "d", "row": 7, "column": 12, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "_", "row": 7, "column": 13, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "n", "row": 7, "column": 14, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "u", "row": 7, "column": 15, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "m", "row": 7, "column": 16, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "b", "row": 7, "column": 17, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "e", "row": 7, "column": 18, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "r", "row": 7, "column": 19, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "t", "row": 7, "column": 20, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "h", "row": 7, "column": 21, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "e", "row": 7, "column": 22, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "o", "row": 7, "column": 23, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "r", "row": 7, "column": 24, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "y", "row": 7, "column": 25, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "_", "row": 7, "column": 26, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "1", "row": 7, "column": 27, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "3", "row": 7, "column": 28, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": "5", "row": 7, "column": 29, "range": {"start": {"line": 7, "character": 8}, "end": {"line": 7, "character": 30}}, "contents": {"value": "```lean\nmathd_numbertheory_135 (n A B C : ℕ) (h₀ : n = 3 ^ 17 + 3 ^ 10) (h₁ : 11 ∣ n + 1)\n  (h₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]) (h₃ : {A, B, C} ⊂ Finset.Icc 0 9) (h₄ : Odd A ∧ Odd C)\n  (h₅ : ¬3 ∣ B) (h₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]) : 100 * A + 10 * B + C = 129\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 30}
{"character": "(", "row": 7, "column": 31, "range": {"start": {"line": 7, "character": 31}, "end": {"line": 7, "character": 38}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "n", "row": 7, "column": 32, "range": {"start": {"line": 7, "character": 32}, "end": {"line": 7, "character": 33}}, "contents": {"value": "```lean\nn : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 33}
{"character": ":", "row": 7, "column": 34, "range": {"start": {"line": 7, "character": 31}, "end": {"line": 7, "character": 38}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 35}
{"character": "ℕ", "row": 7, "column": 36, "range": {"start": {"line": 7, "character": 36}, "end": {"line": 7, "character": 37}}, "contents": {"value": "```lean\nNat : Type\n```\n***\nThe natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n\n***\n*import Init.Prelude*", "kind": "markdown"}}
{"character": ")", "row": 7, "column": 37, "range": {"start": {"line": 7, "character": 31}, "end": {"line": 7, "character": 38}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 38}
{"character": "(", "row": 7, "column": 39, "range": {"start": {"line": 7, "character": 39}, "end": {"line": 7, "character": 46}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "A", "row": 7, "column": 40, "range": {"start": {"line": 7, "character": 40}, "end": {"line": 7, "character": 41}}, "contents": {"value": "```lean\nA : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 41}
{"character": ":", "row": 7, "column": 42, "range": {"start": {"line": 7, "character": 39}, "end": {"line": 7, "character": 46}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 43}
{"character": "ℕ", "row": 7, "column": 44, "range": {"start": {"line": 7, "character": 44}, "end": {"line": 7, "character": 45}}, "contents": {"value": "```lean\nNat : Type\n```\n***\nThe natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n\n***\n*import Init.Prelude*", "kind": "markdown"}}
{"character": ")", "row": 7, "column": 45, "range": {"start": {"line": 7, "character": 39}, "end": {"line": 7, "character": 46}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 46}
{"character": "(", "row": 7, "column": 47, "range": {"start": {"line": 7, "character": 47}, "end": {"line": 7, "character": 54}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "B", "row": 7, "column": 48, "range": {"start": {"line": 7, "character": 48}, "end": {"line": 7, "character": 49}}, "contents": {"value": "```lean\nB : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 49}
{"character": ":", "row": 7, "column": 50, "range": {"start": {"line": 7, "character": 47}, "end": {"line": 7, "character": 54}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 51}
{"character": "ℕ", "row": 7, "column": 52, "range": {"start": {"line": 7, "character": 52}, "end": {"line": 7, "character": 53}}, "contents": {"value": "```lean\nNat : Type\n```\n***\nThe natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n\n***\n*import Init.Prelude*", "kind": "markdown"}}
{"character": ")", "row": 7, "column": 53, "range": {"start": {"line": 7, "character": 47}, "end": {"line": 7, "character": 54}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 54}
{"character": "(", "row": 7, "column": 55, "range": {"start": {"line": 7, "character": 55}, "end": {"line": 7, "character": 62}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "C", "row": 7, "column": 56, "range": {"start": {"line": 7, "character": 56}, "end": {"line": 7, "character": 57}}, "contents": {"value": "```lean\nC : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 57}
{"character": ":", "row": 7, "column": 58, "range": {"start": {"line": 7, "character": 55}, "end": {"line": 7, "character": 62}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 59}
{"character": "ℕ", "row": 7, "column": 60, "range": {"start": {"line": 7, "character": 60}, "end": {"line": 7, "character": 61}}, "contents": {"value": "```lean\nNat : Type\n```\n***\nThe natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n\n***\n*import Init.Prelude*", "kind": "markdown"}}
{"character": ")", "row": 7, "column": 61, "range": {"start": {"line": 7, "character": 55}, "end": {"line": 7, "character": 62}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 62}
{"character": "(", "row": 7, "column": 63, "range": {"start": {"line": 7, "character": 63}, "end": {"line": 7, "character": 89}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "h", "row": 7, "column": 64, "range": {"start": {"line": 7, "character": 64}, "end": {"line": 7, "character": 66}}, "contents": {"value": "```lean\nh₀ : n = 3 ^ 17 + 3 ^ 10\n```", "kind": "markdown"}}
{"character": "₀", "row": 7, "column": 65, "range": {"start": {"line": 7, "character": 64}, "end": {"line": 7, "character": 66}}, "contents": {"value": "```lean\nh₀ : n = 3 ^ 17 + 3 ^ 10\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 66}
{"character": ":", "row": 7, "column": 67, "range": {"start": {"line": 7, "character": 63}, "end": {"line": 7, "character": 89}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 68}
{"character": "n", "row": 7, "column": 69, "range": {"start": {"line": 7, "character": 69}, "end": {"line": 7, "character": 70}}, "contents": {"value": "```lean\nn : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 70, "range": {"start": {"line": 7, "character": 69}, "end": {"line": 7, "character": 88}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "=", "row": 7, "column": 71, "range": {"start": {"line": 7, "character": 69}, "end": {"line": 7, "character": 88}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 72, "range": {"start": {"line": 7, "character": 69}, "end": {"line": 7, "character": 88}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "3", "row": 7, "column": 73, "range": {"start": {"line": 7, "character": 73}, "end": {"line": 7, "character": 74}}, "contents": {"value": "```lean\n3 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 74, "range": {"start": {"line": 7, "character": 73}, "end": {"line": 7, "character": 79}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^` in identifiers is `pow`.", "kind": "markdown"}}
{"character": "^", "row": 7, "column": 75, "range": {"start": {"line": 7, "character": 73}, "end": {"line": 7, "character": 79}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^` in identifiers is `pow`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 76, "range": {"start": {"line": 7, "character": 73}, "end": {"line": 7, "character": 79}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^` in identifiers is `pow`.", "kind": "markdown"}}
{"character": "1", "row": 7, "column": 77, "range": {"start": {"line": 7, "character": 77}, "end": {"line": 7, "character": 79}}, "contents": {"value": "```lean\n17 : ℕ\n```", "kind": "markdown"}}
{"character": "7", "row": 7, "column": 78, "range": {"start": {"line": 7, "character": 77}, "end": {"line": 7, "character": 79}}, "contents": {"value": "```lean\n17 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 79, "range": {"start": {"line": 7, "character": 73}, "end": {"line": 7, "character": 88}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.", "kind": "markdown"}}
{"character": "+", "row": 7, "column": 80, "range": {"start": {"line": 7, "character": 73}, "end": {"line": 7, "character": 88}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 81, "range": {"start": {"line": 7, "character": 73}, "end": {"line": 7, "character": 88}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.", "kind": "markdown"}}
{"character": "3", "row": 7, "column": 82, "range": {"start": {"line": 7, "character": 82}, "end": {"line": 7, "character": 83}}, "contents": {"value": "```lean\n3 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 83, "range": {"start": {"line": 7, "character": 82}, "end": {"line": 7, "character": 88}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^` in identifiers is `pow`.", "kind": "markdown"}}
{"character": "^", "row": 7, "column": 84, "range": {"start": {"line": 7, "character": 82}, "end": {"line": 7, "character": 88}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^` in identifiers is `pow`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 85, "range": {"start": {"line": 7, "character": 82}, "end": {"line": 7, "character": 88}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^` in identifiers is `pow`.", "kind": "markdown"}}
{"character": "1", "row": 7, "column": 86, "range": {"start": {"line": 7, "character": 86}, "end": {"line": 7, "character": 88}}, "contents": {"value": "```lean\n10 : ℕ\n```", "kind": "markdown"}}
{"character": "0", "row": 7, "column": 87, "range": {"start": {"line": 7, "character": 86}, "end": {"line": 7, "character": 88}}, "contents": {"value": "```lean\n10 : ℕ\n```", "kind": "markdown"}}
{"character": ")", "row": 7, "column": 88, "range": {"start": {"line": 7, "character": 63}, "end": {"line": 7, "character": 89}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 89}
{"character": "(", "row": 7, "column": 90, "range": {"start": {"line": 7, "character": 90}, "end": {"line": 7, "character": 107}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "h", "row": 7, "column": 91, "range": {"start": {"line": 7, "character": 91}, "end": {"line": 7, "character": 93}}, "contents": {"value": "```lean\nh₁ : 11 ∣ n + 1\n```", "kind": "markdown"}}
{"character": "₁", "row": 7, "column": 92, "range": {"start": {"line": 7, "character": 91}, "end": {"line": 7, "character": 93}}, "contents": {"value": "```lean\nh₁ : 11 ∣ n + 1\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 93}
{"character": ":", "row": 7, "column": 94, "range": {"start": {"line": 7, "character": 90}, "end": {"line": 7, "character": 107}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 95}
{"character": "1", "row": 7, "column": 96, "range": {"start": {"line": 7, "character": 96}, "end": {"line": 7, "character": 98}}, "contents": {"value": "```lean\n11 : ℕ\n```", "kind": "markdown"}}
{"character": "1", "row": 7, "column": 97, "range": {"start": {"line": 7, "character": 96}, "end": {"line": 7, "character": 98}}, "contents": {"value": "```lean\n11 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 98, "range": {"start": {"line": 7, "character": 96}, "end": {"line": 7, "character": 106}}, "contents": {"value": "```lean\nProp\n```\n***\nDivisibility. `a ∣ b` (typed as `\\|`) means that there is some `c` such that `b = a * c`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∣` in identifiers is `dvd`.", "kind": "markdown"}}
{"character": "∣", "row": 7, "column": 99, "range": {"start": {"line": 7, "character": 96}, "end": {"line": 7, "character": 106}}, "contents": {"value": "```lean\nProp\n```\n***\nDivisibility. `a ∣ b` (typed as `\\|`) means that there is some `c` such that `b = a * c`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∣` in identifiers is `dvd`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 100, "range": {"start": {"line": 7, "character": 96}, "end": {"line": 7, "character": 106}}, "contents": {"value": "```lean\nProp\n```\n***\nDivisibility. `a ∣ b` (typed as `\\|`) means that there is some `c` such that `b = a * c`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∣` in identifiers is `dvd`.", "kind": "markdown"}}
{"character": "n", "row": 7, "column": 101, "range": {"start": {"line": 7, "character": 101}, "end": {"line": 7, "character": 102}}, "contents": {"value": "```lean\nn : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 102, "range": {"start": {"line": 7, "character": 101}, "end": {"line": 7, "character": 106}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.", "kind": "markdown"}}
{"character": "+", "row": 7, "column": 103, "range": {"start": {"line": 7, "character": 101}, "end": {"line": 7, "character": 106}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 104, "range": {"start": {"line": 7, "character": 101}, "end": {"line": 7, "character": 106}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.", "kind": "markdown"}}
{"character": "1", "row": 7, "column": 105, "range": {"start": {"line": 7, "character": 105}, "end": {"line": 7, "character": 106}}, "contents": {"value": "```lean\n1 : ℕ\n```", "kind": "markdown"}}
{"character": ")", "row": 7, "column": 106, "range": {"start": {"line": 7, "character": 90}, "end": {"line": 7, "character": 107}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 107}
{"character": "(", "row": 7, "column": 108, "range": {"start": {"line": 7, "character": 108}, "end": {"line": 7, "character": 161}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "h", "row": 7, "column": 109, "range": {"start": {"line": 7, "character": 109}, "end": {"line": 7, "character": 111}}, "contents": {"value": "```lean\nh₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]\n```", "kind": "markdown"}}
{"character": "₂", "row": 7, "column": 110, "range": {"start": {"line": 7, "character": 109}, "end": {"line": 7, "character": 111}}, "contents": {"value": "```lean\nh₂ : List.Pairwise (fun x1 x2 => x1 ≠ x2) [A, B, C]\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 111}
{"character": ":", "row": 7, "column": 112, "range": {"start": {"line": 7, "character": 108}, "end": {"line": 7, "character": 161}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 113}
{"character": "L", "row": 7, "column": 114, "range": {"start": {"line": 7, "character": 114}, "end": {"line": 7, "character": 127}}, "contents": {"value": "```lean\nList.Pairwise.{u} {α : Type u} (R : α → α → Prop) : List α → Prop\n```\n***\nEach element of a list is related to all later elements of the list by `R`.\n\n`Pairwise R l` means that all the elements of `l` with earlier indexes are `R`-related to all the\nelements with later indexes.\n\nFor example, `Pairwise (· ≠ ·) l` asserts that `l` has no duplicates, and if `Pairwise (· < ·) l`\nasserts that `l` is (strictly) sorted.\n\nExamples:\n * `Pairwise (· < ·) [1, 2, 3] ↔ (1 < 2 ∧ 1 < 3) ∧ 2 < 3`\n * `Pairwise (· = ·) [1, 2, 3] = False`\n * `Pairwise (· ≠ ·) [1, 2, 3] = True`\n\n***\n*import Init.Data.List.Basic*", "kind": "markdown"}}
{"character": "i", "row": 7, "column": 115, "range": {"start": {"line": 7, "character": 114}, "end": {"line": 7, "character": 127}}, "contents": {"value": "```lean\nList.Pairwise.{u} {α : Type u} (R : α → α → Prop) : List α → Prop\n```\n***\nEach element of a list is related to all later elements of the list by `R`.\n\n`Pairwise R l` means that all the elements of `l` with earlier indexes are `R`-related to all the\nelements with later indexes.\n\nFor example, `Pairwise (· ≠ ·) l` asserts that `l` has no duplicates, and if `Pairwise (· < ·) l`\nasserts that `l` is (strictly) sorted.\n\nExamples:\n * `Pairwise (· < ·) [1, 2, 3] ↔ (1 < 2 ∧ 1 < 3) ∧ 2 < 3`\n * `Pairwise (· = ·) [1, 2, 3] = False`\n * `Pairwise (· ≠ ·) [1, 2, 3] = True`\n\n***\n*import Init.Data.List.Basic*", "kind": "markdown"}}
{"character": "s", "row": 7, "column": 116, "range": {"start": {"line": 7, "character": 114}, "end": {"line": 7, "character": 127}}, "contents": {"value": "```lean\nList.Pairwise.{u} {α : Type u} (R : α → α → Prop) : List α → Prop\n```\n***\nEach element of a list is related to all later elements of the list by `R`.\n\n`Pairwise R l` means that all the elements of `l` with earlier indexes are `R`-related to all the\nelements with later indexes.\n\nFor example, `Pairwise (· ≠ ·) l` asserts that `l` has no duplicates, and if `Pairwise (· < ·) l`\nasserts that `l` is (strictly) sorted.\n\nExamples:\n * `Pairwise (· < ·) [1, 2, 3] ↔ (1 < 2 ∧ 1 < 3) ∧ 2 < 3`\n * `Pairwise (· = ·) [1, 2, 3] = False`\n * `Pairwise (· ≠ ·) [1, 2, 3] = True`\n\n***\n*import Init.Data.List.Basic*", "kind": "markdown"}}
{"character": "t", "row": 7, "column": 117, "range": {"start": {"line": 7, "character": 114}, "end": {"line": 7, "character": 127}}, "contents": {"value": "```lean\nList.Pairwise.{u} {α : Type u} (R : α → α → Prop) : List α → Prop\n```\n***\nEach element of a list is related to all later elements of the list by `R`.\n\n`Pairwise R l` means that all the elements of `l` with earlier indexes are `R`-related to all the\nelements with later indexes.\n\nFor example, `Pairwise (· ≠ ·) l` asserts that `l` has no duplicates, and if `Pairwise (· < ·) l`\nasserts that `l` is (strictly) sorted.\n\nExamples:\n * `Pairwise (· < ·) [1, 2, 3] ↔ (1 < 2 ∧ 1 < 3) ∧ 2 < 3`\n * `Pairwise (· = ·) [1, 2, 3] = False`\n * `Pairwise (· ≠ ·) [1, 2, 3] = True`\n\n***\n*import Init.Data.List.Basic*", "kind": "markdown"}}
{"character": ".", "row": 7, "column": 118, "range": {"start": {"line": 7, "character": 114}, "end": {"line": 7, "character": 127}}, "contents": {"value": "```lean\nList.Pairwise.{u} {α : Type u} (R : α → α → Prop) : List α → Prop\n```\n***\nEach element of a list is related to all later elements of the list by `R`.\n\n`Pairwise R l` means that all the elements of `l` with earlier indexes are `R`-related to all the\nelements with later indexes.\n\nFor example, `Pairwise (· ≠ ·) l` asserts that `l` has no duplicates, and if `Pairwise (· < ·) l`\nasserts that `l` is (strictly) sorted.\n\nExamples:\n * `Pairwise (· < ·) [1, 2, 3] ↔ (1 < 2 ∧ 1 < 3) ∧ 2 < 3`\n * `Pairwise (· = ·) [1, 2, 3] = False`\n * `Pairwise (· ≠ ·) [1, 2, 3] = True`\n\n***\n*import Init.Data.List.Basic*", "kind": "markdown"}}
{"character": "P", "row": 7, "column": 119, "range": {"start": {"line": 7, "character": 114}, "end": {"line": 7, "character": 127}}, "contents": {"value": "```lean\nList.Pairwise.{u} {α : Type u} (R : α → α → Prop) : List α → Prop\n```\n***\nEach element of a list is related to all later elements of the list by `R`.\n\n`Pairwise R l` means that all the elements of `l` with earlier indexes are `R`-related to all the\nelements with later indexes.\n\nFor example, `Pairwise (· ≠ ·) l` asserts that `l` has no duplicates, and if `Pairwise (· < ·) l`\nasserts that `l` is (strictly) sorted.\n\nExamples:\n * `Pairwise (· < ·) [1, 2, 3] ↔ (1 < 2 ∧ 1 < 3) ∧ 2 < 3`\n * `Pairwise (· = ·) [1, 2, 3] = False`\n * `Pairwise (· ≠ ·) [1, 2, 3] = True`\n\n***\n*import Init.Data.List.Basic*", "kind": "markdown"}}
{"character": "a", "row": 7, "column": 120, "range": {"start": {"line": 7, "character": 114}, "end": {"line": 7, "character": 127}}, "contents": {"value": "```lean\nList.Pairwise.{u} {α : Type u} (R : α → α → Prop) : List α → Prop\n```\n***\nEach element of a list is related to all later elements of the list by `R`.\n\n`Pairwise R l` means that all the elements of `l` with earlier indexes are `R`-related to all the\nelements with later indexes.\n\nFor example, `Pairwise (· ≠ ·) l` asserts that `l` has no duplicates, and if `Pairwise (· < ·) l`\nasserts that `l` is (strictly) sorted.\n\nExamples:\n * `Pairwise (· < ·) [1, 2, 3] ↔ (1 < 2 ∧ 1 < 3) ∧ 2 < 3`\n * `Pairwise (· = ·) [1, 2, 3] = False`\n * `Pairwise (· ≠ ·) [1, 2, 3] = True`\n\n***\n*import Init.Data.List.Basic*", "kind": "markdown"}}
{"character": "i", "row": 7, "column": 121, "range": {"start": {"line": 7, "character": 114}, "end": {"line": 7, "character": 127}}, "contents": {"value": "```lean\nList.Pairwise.{u} {α : Type u} (R : α → α → Prop) : List α → Prop\n```\n***\nEach element of a list is related to all later elements of the list by `R`.\n\n`Pairwise R l` means that all the elements of `l` with earlier indexes are `R`-related to all the\nelements with later indexes.\n\nFor example, `Pairwise (· ≠ ·) l` asserts that `l` has no duplicates, and if `Pairwise (· < ·) l`\nasserts that `l` is (strictly) sorted.\n\nExamples:\n * `Pairwise (· < ·) [1, 2, 3] ↔ (1 < 2 ∧ 1 < 3) ∧ 2 < 3`\n * `Pairwise (· = ·) [1, 2, 3] = False`\n * `Pairwise (· ≠ ·) [1, 2, 3] = True`\n\n***\n*import Init.Data.List.Basic*", "kind": "markdown"}}
{"character": "r", "row": 7, "column": 122, "range": {"start": {"line": 7, "character": 114}, "end": {"line": 7, "character": 127}}, "contents": {"value": "```lean\nList.Pairwise.{u} {α : Type u} (R : α → α → Prop) : List α → Prop\n```\n***\nEach element of a list is related to all later elements of the list by `R`.\n\n`Pairwise R l` means that all the elements of `l` with earlier indexes are `R`-related to all the\nelements with later indexes.\n\nFor example, `Pairwise (· ≠ ·) l` asserts that `l` has no duplicates, and if `Pairwise (· < ·) l`\nasserts that `l` is (strictly) sorted.\n\nExamples:\n * `Pairwise (· < ·) [1, 2, 3] ↔ (1 < 2 ∧ 1 < 3) ∧ 2 < 3`\n * `Pairwise (· = ·) [1, 2, 3] = False`\n * `Pairwise (· ≠ ·) [1, 2, 3] = True`\n\n***\n*import Init.Data.List.Basic*", "kind": "markdown"}}
{"character": "w", "row": 7, "column": 123, "range": {"start": {"line": 7, "character": 114}, "end": {"line": 7, "character": 127}}, "contents": {"value": "```lean\nList.Pairwise.{u} {α : Type u} (R : α → α → Prop) : List α → Prop\n```\n***\nEach element of a list is related to all later elements of the list by `R`.\n\n`Pairwise R l` means that all the elements of `l` with earlier indexes are `R`-related to all the\nelements with later indexes.\n\nFor example, `Pairwise (· ≠ ·) l` asserts that `l` has no duplicates, and if `Pairwise (· < ·) l`\nasserts that `l` is (strictly) sorted.\n\nExamples:\n * `Pairwise (· < ·) [1, 2, 3] ↔ (1 < 2 ∧ 1 < 3) ∧ 2 < 3`\n * `Pairwise (· = ·) [1, 2, 3] = False`\n * `Pairwise (· ≠ ·) [1, 2, 3] = True`\n\n***\n*import Init.Data.List.Basic*", "kind": "markdown"}}
{"character": "i", "row": 7, "column": 124, "range": {"start": {"line": 7, "character": 114}, "end": {"line": 7, "character": 127}}, "contents": {"value": "```lean\nList.Pairwise.{u} {α : Type u} (R : α → α → Prop) : List α → Prop\n```\n***\nEach element of a list is related to all later elements of the list by `R`.\n\n`Pairwise R l` means that all the elements of `l` with earlier indexes are `R`-related to all the\nelements with later indexes.\n\nFor example, `Pairwise (· ≠ ·) l` asserts that `l` has no duplicates, and if `Pairwise (· < ·) l`\nasserts that `l` is (strictly) sorted.\n\nExamples:\n * `Pairwise (· < ·) [1, 2, 3] ↔ (1 < 2 ∧ 1 < 3) ∧ 2 < 3`\n * `Pairwise (· = ·) [1, 2, 3] = False`\n * `Pairwise (· ≠ ·) [1, 2, 3] = True`\n\n***\n*import Init.Data.List.Basic*", "kind": "markdown"}}
{"character": "s", "row": 7, "column": 125, "range": {"start": {"line": 7, "character": 114}, "end": {"line": 7, "character": 127}}, "contents": {"value": "```lean\nList.Pairwise.{u} {α : Type u} (R : α → α → Prop) : List α → Prop\n```\n***\nEach element of a list is related to all later elements of the list by `R`.\n\n`Pairwise R l` means that all the elements of `l` with earlier indexes are `R`-related to all the\nelements with later indexes.\n\nFor example, `Pairwise (· ≠ ·) l` asserts that `l` has no duplicates, and if `Pairwise (· < ·) l`\nasserts that `l` is (strictly) sorted.\n\nExamples:\n * `Pairwise (· < ·) [1, 2, 3] ↔ (1 < 2 ∧ 1 < 3) ∧ 2 < 3`\n * `Pairwise (· = ·) [1, 2, 3] = False`\n * `Pairwise (· ≠ ·) [1, 2, 3] = True`\n\n***\n*import Init.Data.List.Basic*", "kind": "markdown"}}
{"character": "e", "row": 7, "column": 126, "range": {"start": {"line": 7, "character": 114}, "end": {"line": 7, "character": 127}}, "contents": {"value": "```lean\nList.Pairwise.{u} {α : Type u} (R : α → α → Prop) : List α → Prop\n```\n***\nEach element of a list is related to all later elements of the list by `R`.\n\n`Pairwise R l` means that all the elements of `l` with earlier indexes are `R`-related to all the\nelements with later indexes.\n\nFor example, `Pairwise (· ≠ ·) l` asserts that `l` has no duplicates, and if `Pairwise (· < ·) l`\nasserts that `l` is (strictly) sorted.\n\nExamples:\n * `Pairwise (· < ·) [1, 2, 3] ↔ (1 < 2 ∧ 1 < 3) ∧ 2 < 3`\n * `Pairwise (· = ·) [1, 2, 3] = False`\n * `Pairwise (· ≠ ·) [1, 2, 3] = True`\n\n***\n*import Init.Data.List.Basic*", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 127, "range": {"start": {"line": 7, "character": 114}, "end": {"line": 7, "character": 160}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "(", "row": 7, "column": 128, "range": {"start": {"line": 7, "character": 128}, "end": {"line": 7, "character": 150}}, "contents": {"value": "```lean\nℕ → ℕ → Prop\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "f", "row": 7, "column": 129, "range": {"start": {"line": 7, "character": 129}, "end": {"line": 7, "character": 149}}, "contents": {"value": "```lean\nℕ → ℕ → Prop\n```", "kind": "markdown"}}
{"character": "u", "row": 7, "column": 130, "range": {"start": {"line": 7, "character": 129}, "end": {"line": 7, "character": 149}}, "contents": {"value": "```lean\nℕ → ℕ → Prop\n```", "kind": "markdown"}}
{"character": "n", "row": 7, "column": 131, "range": {"start": {"line": 7, "character": 129}, "end": {"line": 7, "character": 149}}, "contents": {"value": "```lean\nℕ → ℕ → Prop\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 132, "range": {"start": {"line": 7, "character": 129}, "end": {"line": 7, "character": 149}}, "contents": {"value": "```lean\nℕ → ℕ → Prop\n```", "kind": "markdown"}}
{"character": "x", "row": 7, "column": 133, "range": {"start": {"line": 7, "character": 133}, "end": {"line": 7, "character": 135}}, "contents": {"value": "```lean\nx1 : ℕ\n```", "kind": "markdown"}}
{"character": "1", "row": 7, "column": 134, "range": {"start": {"line": 7, "character": 133}, "end": {"line": 7, "character": 135}}, "contents": {"value": "```lean\nx1 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 135, "range": {"start": {"line": 7, "character": 129}, "end": {"line": 7, "character": 149}}, "contents": {"value": "```lean\nℕ → ℕ → Prop\n```", "kind": "markdown"}}
{"character": "x", "row": 7, "column": 136, "range": {"start": {"line": 7, "character": 136}, "end": {"line": 7, "character": 138}}, "contents": {"value": "```lean\nx2 : ℕ\n```", "kind": "markdown"}}
{"character": "2", "row": 7, "column": 137, "range": {"start": {"line": 7, "character": 136}, "end": {"line": 7, "character": 138}}, "contents": {"value": "```lean\nx2 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 138, "range": {"start": {"line": 7, "character": 129}, "end": {"line": 7, "character": 149}}, "contents": {"value": "```lean\nℕ → ℕ → Prop\n```", "kind": "markdown"}}
{"character": "=", "row": 7, "column": 139, "range": {"start": {"line": 7, "character": 129}, "end": {"line": 7, "character": 149}}, "contents": {"value": "```lean\nℕ → ℕ → Prop\n```", "kind": "markdown"}}
{"character": ">", "row": 7, "column": 140, "range": {"start": {"line": 7, "character": 129}, "end": {"line": 7, "character": 149}}, "contents": {"value": "```lean\nℕ → ℕ → Prop\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 141, "range": {"start": {"line": 7, "character": 129}, "end": {"line": 7, "character": 149}}, "contents": {"value": "```lean\nℕ → ℕ → Prop\n```", "kind": "markdown"}}
{"character": "x", "row": 7, "column": 142, "range": {"start": {"line": 7, "character": 142}, "end": {"line": 7, "character": 144}}, "contents": {"value": "```lean\nx1 : ℕ\n```", "kind": "markdown"}}
{"character": "1", "row": 7, "column": 143, "range": {"start": {"line": 7, "character": 142}, "end": {"line": 7, "character": 144}}, "contents": {"value": "```lean\nx1 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 144, "range": {"start": {"line": 7, "character": 142}, "end": {"line": 7, "character": 149}}, "contents": {"value": "```lean\nProp\n```\n***\n`a ≠ b`, or `Ne a b` is defined as `¬ (a = b)` or `a = b → False`,\nand asserts that `a` and `b` are not equal.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≠` in identifiers is `ne`.", "kind": "markdown"}}
{"character": "≠", "row": 7, "column": 145, "range": {"start": {"line": 7, "character": 142}, "end": {"line": 7, "character": 149}}, "contents": {"value": "```lean\nProp\n```\n***\n`a ≠ b`, or `Ne a b` is defined as `¬ (a = b)` or `a = b → False`,\nand asserts that `a` and `b` are not equal.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≠` in identifiers is `ne`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 146, "range": {"start": {"line": 7, "character": 142}, "end": {"line": 7, "character": 149}}, "contents": {"value": "```lean\nProp\n```\n***\n`a ≠ b`, or `Ne a b` is defined as `¬ (a = b)` or `a = b → False`,\nand asserts that `a` and `b` are not equal.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≠` in identifiers is `ne`.", "kind": "markdown"}}
{"character": "x", "row": 7, "column": 147, "range": {"start": {"line": 7, "character": 147}, "end": {"line": 7, "character": 149}}, "contents": {"value": "```lean\nx2 : ℕ\n```", "kind": "markdown"}}
{"character": "2", "row": 7, "column": 148, "range": {"start": {"line": 7, "character": 147}, "end": {"line": 7, "character": 149}}, "contents": {"value": "```lean\nx2 : ℕ\n```", "kind": "markdown"}}
{"character": ")", "row": 7, "column": 149, "range": {"start": {"line": 7, "character": 128}, "end": {"line": 7, "character": 150}}, "contents": {"value": "```lean\nℕ → ℕ → Prop\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 150, "range": {"start": {"line": 7, "character": 114}, "end": {"line": 7, "character": 160}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "[", "row": 7, "column": 151, "range": {"start": {"line": 7, "character": 151}, "end": {"line": 7, "character": 160}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": "A", "row": 7, "column": 152, "range": {"start": {"line": 7, "character": 152}, "end": {"line": 7, "character": 153}}, "contents": {"value": "```lean\nA : ℕ\n```", "kind": "markdown"}}
{"character": ",", "row": 7, "column": 153, "range": {"start": {"line": 7, "character": 151}, "end": {"line": 7, "character": 160}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 154, "range": {"start": {"line": 7, "character": 151}, "end": {"line": 7, "character": 160}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": "B", "row": 7, "column": 155, "range": {"start": {"line": 7, "character": 155}, "end": {"line": 7, "character": 156}}, "contents": {"value": "```lean\nB : ℕ\n```", "kind": "markdown"}}
{"character": ",", "row": 7, "column": 156, "range": {"start": {"line": 7, "character": 151}, "end": {"line": 7, "character": 160}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 157, "range": {"start": {"line": 7, "character": 151}, "end": {"line": 7, "character": 160}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": "C", "row": 7, "column": 158, "range": {"start": {"line": 7, "character": 158}, "end": {"line": 7, "character": 159}}, "contents": {"value": "```lean\nC : ℕ\n```", "kind": "markdown"}}
{"character": "]", "row": 7, "column": 159, "range": {"start": {"line": 7, "character": 151}, "end": {"line": 7, "character": 160}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": ")", "row": 7, "column": 160, "range": {"start": {"line": 7, "character": 108}, "end": {"line": 7, "character": 161}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 161}
{"character": "(", "row": 7, "column": 162, "range": {"start": {"line": 7, "character": 162}, "end": {"line": 7, "character": 195}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "h", "row": 7, "column": 163, "range": {"start": {"line": 7, "character": 163}, "end": {"line": 7, "character": 165}}, "contents": {"value": "```lean\nh₃ : {A, B, C} ⊂ Finset.Icc 0 9\n```", "kind": "markdown"}}
{"character": "₃", "row": 7, "column": 164, "range": {"start": {"line": 7, "character": 163}, "end": {"line": 7, "character": 165}}, "contents": {"value": "```lean\nh₃ : {A, B, C} ⊂ Finset.Icc 0 9\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 165}
{"character": ":", "row": 7, "column": 166, "range": {"start": {"line": 7, "character": 162}, "end": {"line": 7, "character": 195}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 167}
{"character": "{", "row": 7, "column": 168, "range": {"start": {"line": 7, "character": 168}, "end": {"line": 7, "character": 177}}, "contents": {"value": "```lean\nFinset ℕ\n```\n***\n`{ a, b, c }` syntax, powered by the `Singleton` and `Insert` typeclasses. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `{x}` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": "A", "row": 7, "column": 169, "range": {"start": {"line": 7, "character": 169}, "end": {"line": 7, "character": 170}}, "contents": {"value": "```lean\nA : ℕ\n```", "kind": "markdown"}}
{"character": ",", "row": 7, "column": 170, "range": {"start": {"line": 7, "character": 168}, "end": {"line": 7, "character": 177}}, "contents": {"value": "```lean\nFinset ℕ\n```\n***\n`{ a, b, c }` syntax, powered by the `Singleton` and `Insert` typeclasses. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `{x}` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 171, "range": {"start": {"line": 7, "character": 168}, "end": {"line": 7, "character": 177}}, "contents": {"value": "```lean\nFinset ℕ\n```\n***\n`{ a, b, c }` syntax, powered by the `Singleton` and `Insert` typeclasses. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `{x}` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": "B", "row": 7, "column": 172, "range": {"start": {"line": 7, "character": 172}, "end": {"line": 7, "character": 173}}, "contents": {"value": "```lean\nB : ℕ\n```", "kind": "markdown"}}
{"character": ",", "row": 7, "column": 173, "range": {"start": {"line": 7, "character": 168}, "end": {"line": 7, "character": 177}}, "contents": {"value": "```lean\nFinset ℕ\n```\n***\n`{ a, b, c }` syntax, powered by the `Singleton` and `Insert` typeclasses. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `{x}` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 174, "range": {"start": {"line": 7, "character": 168}, "end": {"line": 7, "character": 177}}, "contents": {"value": "```lean\nFinset ℕ\n```\n***\n`{ a, b, c }` syntax, powered by the `Singleton` and `Insert` typeclasses. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `{x}` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": "C", "row": 7, "column": 175, "range": {"start": {"line": 7, "character": 175}, "end": {"line": 7, "character": 176}}, "contents": {"value": "```lean\nC : ℕ\n```", "kind": "markdown"}}
{"character": "}", "row": 7, "column": 176, "range": {"start": {"line": 7, "character": 168}, "end": {"line": 7, "character": 177}}, "contents": {"value": "```lean\nFinset ℕ\n```\n***\n`{ a, b, c }` syntax, powered by the `Singleton` and `Insert` typeclasses. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `{x}` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 177, "range": {"start": {"line": 7, "character": 168}, "end": {"line": 7, "character": 194}}, "contents": {"value": "```lean\nProp\n```\n***\nStrict subset relation: `a ⊂ b`  \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `⊂` in identifiers is `ssubset`.", "kind": "markdown"}}
{"character": "⊂", "row": 7, "column": 178, "range": {"start": {"line": 7, "character": 168}, "end": {"line": 7, "character": 194}}, "contents": {"value": "```lean\nProp\n```\n***\nStrict subset relation: `a ⊂ b`  \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `⊂` in identifiers is `ssubset`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 179, "range": {"start": {"line": 7, "character": 168}, "end": {"line": 7, "character": 194}}, "contents": {"value": "```lean\nProp\n```\n***\nStrict subset relation: `a ⊂ b`  \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `⊂` in identifiers is `ssubset`.", "kind": "markdown"}}
{"character": "F", "row": 7, "column": 180, "range": {"start": {"line": 7, "character": 180}, "end": {"line": 7, "character": 190}}, "contents": {"value": "```lean\nFinset.Icc.{u_1} {α : Type u_1} [Preorder α] [LocallyFiniteOrder α] (a b : α) : Finset α\n```\n***\nThe finset $[a, b]$ of elements `x` such that `a ≤ x` and `x ≤ b`. Basically `Set.Icc a b` as a\nfinset. \n***\n*import Mathlib.Order.Interval.Finset.Defs*", "kind": "markdown"}}
{"character": "i", "row": 7, "column": 181, "range": {"start": {"line": 7, "character": 180}, "end": {"line": 7, "character": 190}}, "contents": {"value": "```lean\nFinset.Icc.{u_1} {α : Type u_1} [Preorder α] [LocallyFiniteOrder α] (a b : α) : Finset α\n```\n***\nThe finset $[a, b]$ of elements `x` such that `a ≤ x` and `x ≤ b`. Basically `Set.Icc a b` as a\nfinset. \n***\n*import Mathlib.Order.Interval.Finset.Defs*", "kind": "markdown"}}
{"character": "n", "row": 7, "column": 182, "range": {"start": {"line": 7, "character": 180}, "end": {"line": 7, "character": 190}}, "contents": {"value": "```lean\nFinset.Icc.{u_1} {α : Type u_1} [Preorder α] [LocallyFiniteOrder α] (a b : α) : Finset α\n```\n***\nThe finset $[a, b]$ of elements `x` such that `a ≤ x` and `x ≤ b`. Basically `Set.Icc a b` as a\nfinset. \n***\n*import Mathlib.Order.Interval.Finset.Defs*", "kind": "markdown"}}
{"character": "s", "row": 7, "column": 183, "range": {"start": {"line": 7, "character": 180}, "end": {"line": 7, "character": 190}}, "contents": {"value": "```lean\nFinset.Icc.{u_1} {α : Type u_1} [Preorder α] [LocallyFiniteOrder α] (a b : α) : Finset α\n```\n***\nThe finset $[a, b]$ of elements `x` such that `a ≤ x` and `x ≤ b`. Basically `Set.Icc a b` as a\nfinset. \n***\n*import Mathlib.Order.Interval.Finset.Defs*", "kind": "markdown"}}
{"character": "e", "row": 7, "column": 184, "range": {"start": {"line": 7, "character": 180}, "end": {"line": 7, "character": 190}}, "contents": {"value": "```lean\nFinset.Icc.{u_1} {α : Type u_1} [Preorder α] [LocallyFiniteOrder α] (a b : α) : Finset α\n```\n***\nThe finset $[a, b]$ of elements `x` such that `a ≤ x` and `x ≤ b`. Basically `Set.Icc a b` as a\nfinset. \n***\n*import Mathlib.Order.Interval.Finset.Defs*", "kind": "markdown"}}
{"character": "t", "row": 7, "column": 185, "range": {"start": {"line": 7, "character": 180}, "end": {"line": 7, "character": 190}}, "contents": {"value": "```lean\nFinset.Icc.{u_1} {α : Type u_1} [Preorder α] [LocallyFiniteOrder α] (a b : α) : Finset α\n```\n***\nThe finset $[a, b]$ of elements `x` such that `a ≤ x` and `x ≤ b`. Basically `Set.Icc a b` as a\nfinset. \n***\n*import Mathlib.Order.Interval.Finset.Defs*", "kind": "markdown"}}
{"character": ".", "row": 7, "column": 186, "range": {"start": {"line": 7, "character": 180}, "end": {"line": 7, "character": 190}}, "contents": {"value": "```lean\nFinset.Icc.{u_1} {α : Type u_1} [Preorder α] [LocallyFiniteOrder α] (a b : α) : Finset α\n```\n***\nThe finset $[a, b]$ of elements `x` such that `a ≤ x` and `x ≤ b`. Basically `Set.Icc a b` as a\nfinset. \n***\n*import Mathlib.Order.Interval.Finset.Defs*", "kind": "markdown"}}
{"character": "I", "row": 7, "column": 187, "range": {"start": {"line": 7, "character": 180}, "end": {"line": 7, "character": 190}}, "contents": {"value": "```lean\nFinset.Icc.{u_1} {α : Type u_1} [Preorder α] [LocallyFiniteOrder α] (a b : α) : Finset α\n```\n***\nThe finset $[a, b]$ of elements `x` such that `a ≤ x` and `x ≤ b`. Basically `Set.Icc a b` as a\nfinset. \n***\n*import Mathlib.Order.Interval.Finset.Defs*", "kind": "markdown"}}
{"character": "c", "row": 7, "column": 188, "range": {"start": {"line": 7, "character": 180}, "end": {"line": 7, "character": 190}}, "contents": {"value": "```lean\nFinset.Icc.{u_1} {α : Type u_1} [Preorder α] [LocallyFiniteOrder α] (a b : α) : Finset α\n```\n***\nThe finset $[a, b]$ of elements `x` such that `a ≤ x` and `x ≤ b`. Basically `Set.Icc a b` as a\nfinset. \n***\n*import Mathlib.Order.Interval.Finset.Defs*", "kind": "markdown"}}
{"character": "c", "row": 7, "column": 189, "range": {"start": {"line": 7, "character": 180}, "end": {"line": 7, "character": 190}}, "contents": {"value": "```lean\nFinset.Icc.{u_1} {α : Type u_1} [Preorder α] [LocallyFiniteOrder α] (a b : α) : Finset α\n```\n***\nThe finset $[a, b]$ of elements `x` such that `a ≤ x` and `x ≤ b`. Basically `Set.Icc a b` as a\nfinset. \n***\n*import Mathlib.Order.Interval.Finset.Defs*", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 190, "range": {"start": {"line": 7, "character": 180}, "end": {"line": 7, "character": 194}}, "contents": {"value": "```lean\nFinset ℕ\n```", "kind": "markdown"}}
{"character": "0", "row": 7, "column": 191, "range": {"start": {"line": 7, "character": 191}, "end": {"line": 7, "character": 192}}, "contents": {"value": "```lean\n0 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 192, "range": {"start": {"line": 7, "character": 180}, "end": {"line": 7, "character": 194}}, "contents": {"value": "```lean\nFinset ℕ\n```", "kind": "markdown"}}
{"character": "9", "row": 7, "column": 193, "range": {"start": {"line": 7, "character": 193}, "end": {"line": 7, "character": 194}}, "contents": {"value": "```lean\n9 : ℕ\n```", "kind": "markdown"}}
{"character": ")", "row": 7, "column": 194, "range": {"start": {"line": 7, "character": 162}, "end": {"line": 7, "character": 195}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 195}
{"character": "(", "row": 7, "column": 196, "range": {"start": {"line": 7, "character": 196}, "end": {"line": 7, "character": 216}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "h", "row": 7, "column": 197, "range": {"start": {"line": 7, "character": 197}, "end": {"line": 7, "character": 199}}, "contents": {"value": "```lean\nh₄ : Odd A ∧ Odd C\n```", "kind": "markdown"}}
{"character": "₄", "row": 7, "column": 198, "range": {"start": {"line": 7, "character": 197}, "end": {"line": 7, "character": 199}}, "contents": {"value": "```lean\nh₄ : Odd A ∧ Odd C\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 199}
{"character": ":", "row": 7, "column": 200, "range": {"start": {"line": 7, "character": 196}, "end": {"line": 7, "character": 216}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 201}
{"character": "O", "row": 7, "column": 202, "range": {"start": {"line": 7, "character": 202}, "end": {"line": 7, "character": 205}}, "contents": {"value": "```lean\nOdd.{u_2} {α : Type u_2} [Semiring α] (a : α) : Prop\n```\n***\nAn element `a` of a semiring is odd if there exists `k` such `a = 2*k + 1`. \n***\n*import Mathlib.Algebra.Ring.Parity*", "kind": "markdown"}}
{"character": "d", "row": 7, "column": 203, "range": {"start": {"line": 7, "character": 202}, "end": {"line": 7, "character": 205}}, "contents": {"value": "```lean\nOdd.{u_2} {α : Type u_2} [Semiring α] (a : α) : Prop\n```\n***\nAn element `a` of a semiring is odd if there exists `k` such `a = 2*k + 1`. \n***\n*import Mathlib.Algebra.Ring.Parity*", "kind": "markdown"}}
{"character": "d", "row": 7, "column": 204, "range": {"start": {"line": 7, "character": 202}, "end": {"line": 7, "character": 205}}, "contents": {"value": "```lean\nOdd.{u_2} {α : Type u_2} [Semiring α] (a : α) : Prop\n```\n***\nAn element `a` of a semiring is odd if there exists `k` such `a = 2*k + 1`. \n***\n*import Mathlib.Algebra.Ring.Parity*", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 205, "range": {"start": {"line": 7, "character": 202}, "end": {"line": 7, "character": 207}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "A", "row": 7, "column": 206, "range": {"start": {"line": 7, "character": 206}, "end": {"line": 7, "character": 207}}, "contents": {"value": "```lean\nA : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 207, "range": {"start": {"line": 7, "character": 202}, "end": {"line": 7, "character": 215}}, "contents": {"value": "```lean\nProp\n```\n***\n`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.", "kind": "markdown"}}
{"character": "∧", "row": 7, "column": 208, "range": {"start": {"line": 7, "character": 202}, "end": {"line": 7, "character": 215}}, "contents": {"value": "```lean\nProp\n```\n***\n`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 209, "range": {"start": {"line": 7, "character": 202}, "end": {"line": 7, "character": 215}}, "contents": {"value": "```lean\nProp\n```\n***\n`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.", "kind": "markdown"}}
{"character": "O", "row": 7, "column": 210, "range": {"start": {"line": 7, "character": 210}, "end": {"line": 7, "character": 213}}, "contents": {"value": "```lean\nOdd.{u_2} {α : Type u_2} [Semiring α] (a : α) : Prop\n```\n***\nAn element `a` of a semiring is odd if there exists `k` such `a = 2*k + 1`. \n***\n*import Mathlib.Algebra.Ring.Parity*", "kind": "markdown"}}
{"character": "d", "row": 7, "column": 211, "range": {"start": {"line": 7, "character": 210}, "end": {"line": 7, "character": 213}}, "contents": {"value": "```lean\nOdd.{u_2} {α : Type u_2} [Semiring α] (a : α) : Prop\n```\n***\nAn element `a` of a semiring is odd if there exists `k` such `a = 2*k + 1`. \n***\n*import Mathlib.Algebra.Ring.Parity*", "kind": "markdown"}}
{"character": "d", "row": 7, "column": 212, "range": {"start": {"line": 7, "character": 210}, "end": {"line": 7, "character": 213}}, "contents": {"value": "```lean\nOdd.{u_2} {α : Type u_2} [Semiring α] (a : α) : Prop\n```\n***\nAn element `a` of a semiring is odd if there exists `k` such `a = 2*k + 1`. \n***\n*import Mathlib.Algebra.Ring.Parity*", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 213, "range": {"start": {"line": 7, "character": 210}, "end": {"line": 7, "character": 215}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "C", "row": 7, "column": 214, "range": {"start": {"line": 7, "character": 214}, "end": {"line": 7, "character": 215}}, "contents": {"value": "```lean\nC : ℕ\n```", "kind": "markdown"}}
{"character": ")", "row": 7, "column": 215, "range": {"start": {"line": 7, "character": 196}, "end": {"line": 7, "character": 216}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 216}
{"character": "(", "row": 7, "column": 217, "range": {"start": {"line": 7, "character": 217}, "end": {"line": 7, "character": 230}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "h", "row": 7, "column": 218, "range": {"start": {"line": 7, "character": 218}, "end": {"line": 7, "character": 220}}, "contents": {"value": "```lean\nh₅ : ¬3 ∣ B\n```", "kind": "markdown"}}
{"character": "₅", "row": 7, "column": 219, "range": {"start": {"line": 7, "character": 218}, "end": {"line": 7, "character": 220}}, "contents": {"value": "```lean\nh₅ : ¬3 ∣ B\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 220}
{"character": ":", "row": 7, "column": 221, "range": {"start": {"line": 7, "character": 217}, "end": {"line": 7, "character": 230}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 222}
{"character": "¬", "row": 7, "column": 223, "range": {"start": {"line": 7, "character": 223}, "end": {"line": 7, "character": 229}}, "contents": {"value": "```lean\nProp\n```\n***\n`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,\nso if your goal is `¬p` you can use `intro h` to turn the goal into\n`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`\nand `(hn h).elim` will prove anything.\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `¬` in identifiers is `not`.", "kind": "markdown"}}
{"character": "3", "row": 7, "column": 224, "range": {"start": {"line": 7, "character": 224}, "end": {"line": 7, "character": 225}}, "contents": {"value": "```lean\n3 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 225, "range": {"start": {"line": 7, "character": 224}, "end": {"line": 7, "character": 229}}, "contents": {"value": "```lean\nProp\n```\n***\nDivisibility. `a ∣ b` (typed as `\\|`) means that there is some `c` such that `b = a * c`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∣` in identifiers is `dvd`.", "kind": "markdown"}}
{"character": "∣", "row": 7, "column": 226, "range": {"start": {"line": 7, "character": 224}, "end": {"line": 7, "character": 229}}, "contents": {"value": "```lean\nProp\n```\n***\nDivisibility. `a ∣ b` (typed as `\\|`) means that there is some `c` such that `b = a * c`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∣` in identifiers is `dvd`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 227, "range": {"start": {"line": 7, "character": 224}, "end": {"line": 7, "character": 229}}, "contents": {"value": "```lean\nProp\n```\n***\nDivisibility. `a ∣ b` (typed as `\\|`) means that there is some `c` such that `b = a * c`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∣` in identifiers is `dvd`.", "kind": "markdown"}}
{"character": "B", "row": 7, "column": 228, "range": {"start": {"line": 7, "character": 228}, "end": {"line": 7, "character": 229}}, "contents": {"value": "```lean\nB : ℕ\n```", "kind": "markdown"}}
{"character": ")", "row": 7, "column": 229, "range": {"start": {"line": 7, "character": 217}, "end": {"line": 7, "character": 230}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 230}
{"character": "(", "row": 7, "column": 231, "range": {"start": {"line": 7, "character": 231}, "end": {"line": 7, "character": 279}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "h", "row": 7, "column": 232, "range": {"start": {"line": 7, "character": 232}, "end": {"line": 7, "character": 234}}, "contents": {"value": "```lean\nh₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]\n```", "kind": "markdown"}}
{"character": "₆", "row": 7, "column": 233, "range": {"start": {"line": 7, "character": 232}, "end": {"line": 7, "character": 234}}, "contents": {"value": "```lean\nh₆ : digits 10 n = [B, A, B, C, C, A, C, B, A]\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 234}
{"character": ":", "row": 7, "column": 235, "range": {"start": {"line": 7, "character": 231}, "end": {"line": 7, "character": 279}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 236}
{"character": "d", "row": 7, "column": 237, "range": {"start": {"line": 7, "character": 237}, "end": {"line": 7, "character": 243}}, "contents": {"value": "```lean\nNat.digits : ℕ → ℕ → List ℕ\n```\n***\n`digits b n` gives the digits, in little-endian order,\nof a natural number `n` in a specified base `b`.\n\nIn any base, we have `ofDigits b L = L.foldr (fun x y ↦ x + b * y) 0`.\n* For any `2 ≤ b`, we have `l < b` for any `l ∈ digits b n`,\n  and the last digit is not zero.\n  This uniquely specifies the behaviour of `digits b`.\n* For `b = 1`, we define `digits 1 n = List.replicate n 1`.\n* For `b = 0`, we define `digits 0 n = [n]`, except `digits 0 0 = []`.\n\nNote this differs from the existing `Nat.toDigits` in core, which is used for printing numerals.\nIn particular, `Nat.toDigits b 0 = ['0']`, while `digits b 0 = []`.\n\n***\n*import Mathlib.Data.Nat.Digits*", "kind": "markdown"}}
{"character": "i", "row": 7, "column": 238, "range": {"start": {"line": 7, "character": 237}, "end": {"line": 7, "character": 243}}, "contents": {"value": "```lean\nNat.digits : ℕ → ℕ → List ℕ\n```\n***\n`digits b n` gives the digits, in little-endian order,\nof a natural number `n` in a specified base `b`.\n\nIn any base, we have `ofDigits b L = L.foldr (fun x y ↦ x + b * y) 0`.\n* For any `2 ≤ b`, we have `l < b` for any `l ∈ digits b n`,\n  and the last digit is not zero.\n  This uniquely specifies the behaviour of `digits b`.\n* For `b = 1`, we define `digits 1 n = List.replicate n 1`.\n* For `b = 0`, we define `digits 0 n = [n]`, except `digits 0 0 = []`.\n\nNote this differs from the existing `Nat.toDigits` in core, which is used for printing numerals.\nIn particular, `Nat.toDigits b 0 = ['0']`, while `digits b 0 = []`.\n\n***\n*import Mathlib.Data.Nat.Digits*", "kind": "markdown"}}
{"character": "g", "row": 7, "column": 239, "range": {"start": {"line": 7, "character": 237}, "end": {"line": 7, "character": 243}}, "contents": {"value": "```lean\nNat.digits : ℕ → ℕ → List ℕ\n```\n***\n`digits b n` gives the digits, in little-endian order,\nof a natural number `n` in a specified base `b`.\n\nIn any base, we have `ofDigits b L = L.foldr (fun x y ↦ x + b * y) 0`.\n* For any `2 ≤ b`, we have `l < b` for any `l ∈ digits b n`,\n  and the last digit is not zero.\n  This uniquely specifies the behaviour of `digits b`.\n* For `b = 1`, we define `digits 1 n = List.replicate n 1`.\n* For `b = 0`, we define `digits 0 n = [n]`, except `digits 0 0 = []`.\n\nNote this differs from the existing `Nat.toDigits` in core, which is used for printing numerals.\nIn particular, `Nat.toDigits b 0 = ['0']`, while `digits b 0 = []`.\n\n***\n*import Mathlib.Data.Nat.Digits*", "kind": "markdown"}}
{"character": "i", "row": 7, "column": 240, "range": {"start": {"line": 7, "character": 237}, "end": {"line": 7, "character": 243}}, "contents": {"value": "```lean\nNat.digits : ℕ → ℕ → List ℕ\n```\n***\n`digits b n` gives the digits, in little-endian order,\nof a natural number `n` in a specified base `b`.\n\nIn any base, we have `ofDigits b L = L.foldr (fun x y ↦ x + b * y) 0`.\n* For any `2 ≤ b`, we have `l < b` for any `l ∈ digits b n`,\n  and the last digit is not zero.\n  This uniquely specifies the behaviour of `digits b`.\n* For `b = 1`, we define `digits 1 n = List.replicate n 1`.\n* For `b = 0`, we define `digits 0 n = [n]`, except `digits 0 0 = []`.\n\nNote this differs from the existing `Nat.toDigits` in core, which is used for printing numerals.\nIn particular, `Nat.toDigits b 0 = ['0']`, while `digits b 0 = []`.\n\n***\n*import Mathlib.Data.Nat.Digits*", "kind": "markdown"}}
{"character": "t", "row": 7, "column": 241, "range": {"start": {"line": 7, "character": 237}, "end": {"line": 7, "character": 243}}, "contents": {"value": "```lean\nNat.digits : ℕ → ℕ → List ℕ\n```\n***\n`digits b n` gives the digits, in little-endian order,\nof a natural number `n` in a specified base `b`.\n\nIn any base, we have `ofDigits b L = L.foldr (fun x y ↦ x + b * y) 0`.\n* For any `2 ≤ b`, we have `l < b` for any `l ∈ digits b n`,\n  and the last digit is not zero.\n  This uniquely specifies the behaviour of `digits b`.\n* For `b = 1`, we define `digits 1 n = List.replicate n 1`.\n* For `b = 0`, we define `digits 0 n = [n]`, except `digits 0 0 = []`.\n\nNote this differs from the existing `Nat.toDigits` in core, which is used for printing numerals.\nIn particular, `Nat.toDigits b 0 = ['0']`, while `digits b 0 = []`.\n\n***\n*import Mathlib.Data.Nat.Digits*", "kind": "markdown"}}
{"character": "s", "row": 7, "column": 242, "range": {"start": {"line": 7, "character": 237}, "end": {"line": 7, "character": 243}}, "contents": {"value": "```lean\nNat.digits : ℕ → ℕ → List ℕ\n```\n***\n`digits b n` gives the digits, in little-endian order,\nof a natural number `n` in a specified base `b`.\n\nIn any base, we have `ofDigits b L = L.foldr (fun x y ↦ x + b * y) 0`.\n* For any `2 ≤ b`, we have `l < b` for any `l ∈ digits b n`,\n  and the last digit is not zero.\n  This uniquely specifies the behaviour of `digits b`.\n* For `b = 1`, we define `digits 1 n = List.replicate n 1`.\n* For `b = 0`, we define `digits 0 n = [n]`, except `digits 0 0 = []`.\n\nNote this differs from the existing `Nat.toDigits` in core, which is used for printing numerals.\nIn particular, `Nat.toDigits b 0 = ['0']`, while `digits b 0 = []`.\n\n***\n*import Mathlib.Data.Nat.Digits*", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 243, "range": {"start": {"line": 7, "character": 237}, "end": {"line": 7, "character": 248}}, "contents": {"value": "```lean\nList ℕ\n```", "kind": "markdown"}}
{"character": "1", "row": 7, "column": 244, "range": {"start": {"line": 7, "character": 244}, "end": {"line": 7, "character": 246}}, "contents": {"value": "```lean\n10 : ℕ\n```", "kind": "markdown"}}
{"character": "0", "row": 7, "column": 245, "range": {"start": {"line": 7, "character": 244}, "end": {"line": 7, "character": 246}}, "contents": {"value": "```lean\n10 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 246, "range": {"start": {"line": 7, "character": 237}, "end": {"line": 7, "character": 248}}, "contents": {"value": "```lean\nList ℕ\n```", "kind": "markdown"}}
{"character": "n", "row": 7, "column": 247, "range": {"start": {"line": 7, "character": 247}, "end": {"line": 7, "character": 248}}, "contents": {"value": "```lean\nn : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 248, "range": {"start": {"line": 7, "character": 237}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "=", "row": 7, "column": 249, "range": {"start": {"line": 7, "character": 237}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 250, "range": {"start": {"line": 7, "character": 237}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "[", "row": 7, "column": 251, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": "B", "row": 7, "column": 252, "range": {"start": {"line": 7, "character": 252}, "end": {"line": 7, "character": 253}}, "contents": {"value": "```lean\nB : ℕ\n```", "kind": "markdown"}}
{"character": ",", "row": 7, "column": 253, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 254, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": "A", "row": 7, "column": 255, "range": {"start": {"line": 7, "character": 255}, "end": {"line": 7, "character": 256}}, "contents": {"value": "```lean\nA : ℕ\n```", "kind": "markdown"}}
{"character": ",", "row": 7, "column": 256, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 257, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": "B", "row": 7, "column": 258, "range": {"start": {"line": 7, "character": 258}, "end": {"line": 7, "character": 259}}, "contents": {"value": "```lean\nB : ℕ\n```", "kind": "markdown"}}
{"character": ",", "row": 7, "column": 259, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 260, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": "C", "row": 7, "column": 261, "range": {"start": {"line": 7, "character": 261}, "end": {"line": 7, "character": 262}}, "contents": {"value": "```lean\nC : ℕ\n```", "kind": "markdown"}}
{"character": ",", "row": 7, "column": 262, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 263, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": "C", "row": 7, "column": 264, "range": {"start": {"line": 7, "character": 264}, "end": {"line": 7, "character": 265}}, "contents": {"value": "```lean\nC : ℕ\n```", "kind": "markdown"}}
{"character": ",", "row": 7, "column": 265, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 266, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": "A", "row": 7, "column": 267, "range": {"start": {"line": 7, "character": 267}, "end": {"line": 7, "character": 268}}, "contents": {"value": "```lean\nA : ℕ\n```", "kind": "markdown"}}
{"character": ",", "row": 7, "column": 268, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 269, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": "C", "row": 7, "column": 270, "range": {"start": {"line": 7, "character": 270}, "end": {"line": 7, "character": 271}}, "contents": {"value": "```lean\nC : ℕ\n```", "kind": "markdown"}}
{"character": ",", "row": 7, "column": 271, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 272, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": "B", "row": 7, "column": 273, "range": {"start": {"line": 7, "character": 273}, "end": {"line": 7, "character": 274}}, "contents": {"value": "```lean\nB : ℕ\n```", "kind": "markdown"}}
{"character": ",", "row": 7, "column": 274, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 275, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": "A", "row": 7, "column": 276, "range": {"start": {"line": 7, "character": 276}, "end": {"line": 7, "character": 277}}, "contents": {"value": "```lean\nA : ℕ\n```", "kind": "markdown"}}
{"character": "]", "row": 7, "column": 277, "range": {"start": {"line": 7, "character": 251}, "end": {"line": 7, "character": 278}}, "contents": {"value": "```lean\nList ℕ\n```\n***\nThe syntax `[a, b, c]` is shorthand for `a :: b :: c :: []`, or\n`List.cons a (List.cons b (List.cons c List.nil))`. It allows conveniently constructing\nlist literals.\n\nFor lists of length at least 64, an alternative desugaring strategy is used\nwhich uses let bindings as intermediates as in\n`let left := [d, e, f]; a :: b :: c :: left` to avoid creating very deep expressions.\nNote that this changes the order of evaluation, although it should not be observable\nunless you use side effecting operations like `dbg_trace`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `[]` in identifiers is `nil`.\n\n * The recommended spelling of `[a]` in identifiers is `singleton`.", "kind": "markdown"}}
{"character": ")", "row": 7, "column": 278, "range": {"start": {"line": 7, "character": 231}, "end": {"line": 7, "character": 279}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 279}
{"character": ":", "row": 7, "column": 280, "range": {"start": {"line": 7, "character": 31}, "end": {"line": 7, "character": 308}}, "contents": {"value": "`declSig` matches the signature of a declaration with required type: a list of binders and then `: type` ", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 281}
{"character": "1", "row": 7, "column": 282, "range": {"start": {"line": 7, "character": 282}, "end": {"line": 7, "character": 285}}, "contents": {"value": "```lean\n100 : ℕ\n```", "kind": "markdown"}}
{"character": "0", "row": 7, "column": 283, "range": {"start": {"line": 7, "character": 282}, "end": {"line": 7, "character": 285}}, "contents": {"value": "```lean\n100 : ℕ\n```", "kind": "markdown"}}
{"character": "0", "row": 7, "column": 284, "range": {"start": {"line": 7, "character": 282}, "end": {"line": 7, "character": 285}}, "contents": {"value": "```lean\n100 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 285, "range": {"start": {"line": 7, "character": 282}, "end": {"line": 7, "character": 289}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*` in identifiers is `mul`.", "kind": "markdown"}}
{"character": "*", "row": 7, "column": 286, "range": {"start": {"line": 7, "character": 282}, "end": {"line": 7, "character": 289}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*` in identifiers is `mul`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 287, "range": {"start": {"line": 7, "character": 282}, "end": {"line": 7, "character": 289}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*` in identifiers is `mul`.", "kind": "markdown"}}
{"character": "A", "row": 7, "column": 288, "range": {"start": {"line": 7, "character": 288}, "end": {"line": 7, "character": 289}}, "contents": {"value": "```lean\nA : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 289, "range": {"start": {"line": 7, "character": 282}, "end": {"line": 7, "character": 298}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.", "kind": "markdown"}}
{"character": "+", "row": 7, "column": 290, "range": {"start": {"line": 7, "character": 282}, "end": {"line": 7, "character": 298}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 291, "range": {"start": {"line": 7, "character": 282}, "end": {"line": 7, "character": 298}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.", "kind": "markdown"}}
{"character": "1", "row": 7, "column": 292, "range": {"start": {"line": 7, "character": 292}, "end": {"line": 7, "character": 294}}, "contents": {"value": "```lean\n10 : ℕ\n```", "kind": "markdown"}}
{"character": "0", "row": 7, "column": 293, "range": {"start": {"line": 7, "character": 292}, "end": {"line": 7, "character": 294}}, "contents": {"value": "```lean\n10 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 294, "range": {"start": {"line": 7, "character": 292}, "end": {"line": 7, "character": 298}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*` in identifiers is `mul`.", "kind": "markdown"}}
{"character": "*", "row": 7, "column": 295, "range": {"start": {"line": 7, "character": 292}, "end": {"line": 7, "character": 298}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*` in identifiers is `mul`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 296, "range": {"start": {"line": 7, "character": 292}, "end": {"line": 7, "character": 298}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*` in identifiers is `mul`.", "kind": "markdown"}}
{"character": "B", "row": 7, "column": 297, "range": {"start": {"line": 7, "character": 297}, "end": {"line": 7, "character": 298}}, "contents": {"value": "```lean\nB : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 298, "range": {"start": {"line": 7, "character": 282}, "end": {"line": 7, "character": 302}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.", "kind": "markdown"}}
{"character": "+", "row": 7, "column": 299, "range": {"start": {"line": 7, "character": 282}, "end": {"line": 7, "character": 302}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 300, "range": {"start": {"line": 7, "character": 282}, "end": {"line": 7, "character": 302}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.", "kind": "markdown"}}
{"character": "C", "row": 7, "column": 301, "range": {"start": {"line": 7, "character": 301}, "end": {"line": 7, "character": 302}}, "contents": {"value": "```lean\nC : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 302, "range": {"start": {"line": 7, "character": 282}, "end": {"line": 7, "character": 308}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "=", "row": 7, "column": 303, "range": {"start": {"line": 7, "character": 282}, "end": {"line": 7, "character": 308}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 304, "range": {"start": {"line": 7, "character": 282}, "end": {"line": 7, "character": 308}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "1", "row": 7, "column": 305, "range": {"start": {"line": 7, "character": 305}, "end": {"line": 7, "character": 308}}, "contents": {"value": "```lean\n129 : ℕ\n```", "kind": "markdown"}}
{"character": "2", "row": 7, "column": 306, "range": {"start": {"line": 7, "character": 305}, "end": {"line": 7, "character": 308}}, "contents": {"value": "```lean\n129 : ℕ\n```", "kind": "markdown"}}
{"character": "9", "row": 7, "column": 307, "range": {"start": {"line": 7, "character": 305}, "end": {"line": 7, "character": 308}}, "contents": {"value": "```lean\n129 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 308}
{"character": ":", "row": 7, "column": 309}
{"character": "=", "row": 7, "column": 310}
{"character": " ", "row": 7, "column": 311}
{"character": "b", "row": 7, "column": 312, "range": {"start": {"line": 7, "character": 312}, "end": {"line": 7, "character": 320}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": "y", "row": 7, "column": 313, "range": {"start": {"line": 7, "character": 312}, "end": {"line": 7, "character": 320}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": " ", "row": 7, "column": 314, "range": {"start": {"line": 7, "character": 312}, "end": {"line": 7, "character": 320}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": "s", "row": 7, "column": 315, "range": {"start": {"line": 7, "character": 315}, "end": {"line": 7, "character": 320}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "o", "row": 7, "column": 316, "range": {"start": {"line": 7, "character": 315}, "end": {"line": 7, "character": 320}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 7, "column": 317, "range": {"start": {"line": 7, "character": 315}, "end": {"line": 7, "character": 320}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 7, "column": 318, "range": {"start": {"line": 7, "character": 315}, "end": {"line": 7, "character": 320}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "y", "row": 7, "column": 319, "range": {"start": {"line": 7, "character": 315}, "end": {"line": 7, "character": 320}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
