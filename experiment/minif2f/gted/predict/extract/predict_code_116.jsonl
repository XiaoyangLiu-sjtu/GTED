{"character": "i", "row": 0, "column": 0}
{"character": "m", "row": 0, "column": 1}
{"character": "p", "row": 0, "column": 2}
{"character": "o", "row": 0, "column": 3}
{"character": "r", "row": 0, "column": 4}
{"character": "t", "row": 0, "column": 5}
{"character": " ", "row": 0, "column": 6}
{"character": "M", "row": 0, "column": 7}
{"character": "a", "row": 0, "column": 8}
{"character": "t", "row": 0, "column": 9}
{"character": "h", "row": 0, "column": 10}
{"character": "l", "row": 0, "column": 11}
{"character": "i", "row": 0, "column": 12}
{"character": "b", "row": 0, "column": 13}
{"character": "t", "row": 2, "column": 0}
{"character": "h", "row": 2, "column": 1}
{"character": "e", "row": 2, "column": 2}
{"character": "o", "row": 2, "column": 3}
{"character": "r", "row": 2, "column": 4}
{"character": "e", "row": 2, "column": 5}
{"character": "m", "row": 2, "column": 6}
{"character": " ", "row": 2, "column": 7}
{"character": "m", "row": 2, "column": 8, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 9, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 10, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "f", "row": 2, "column": 11, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "a", "row": 2, "column": 12, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "v", "row": 2, "column": 13, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 14, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 15, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "i", "row": 2, "column": 16, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 17, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 18, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 19, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 20, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "h", "row": 2, "column": 21, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 22, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 23, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 24, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 25, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": "m", "row": 2, "column": 26, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 27}}, "contents": {"value": "```lean\nmy_favorite_theorem (n : ℕ) : n.gcd 40 = 10 ∧ n.lcm 40 = 280 → n = 70\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 27}
{"character": "(", "row": 2, "column": 28, "range": {"start": {"line": 2, "character": 28}, "end": {"line": 2, "character": 35}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 29, "range": {"start": {"line": 2, "character": 29}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nn : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 30}
{"character": ":", "row": 2, "column": 31, "range": {"start": {"line": 2, "character": 28}, "end": {"line": 2, "character": 35}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 32}
{"character": "ℕ", "row": 2, "column": 33, "range": {"start": {"line": 2, "character": 33}, "end": {"line": 2, "character": 34}}, "contents": {"value": "```lean\nNat : Type\n```\n***\nThe natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n\n***\n*import Init.Prelude*", "kind": "markdown"}}
{"character": ")", "row": 2, "column": 34, "range": {"start": {"line": 2, "character": 28}, "end": {"line": 2, "character": 35}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 35}
{"character": ":", "row": 2, "column": 36, "range": {"start": {"line": 2, "character": 28}, "end": {"line": 2, "character": 77}}, "contents": {"value": "`declSig` matches the signature of a declaration with required type: a list of binders and then `: type` ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 37}
{"character": "n", "row": 2, "column": 38, "range": {"start": {"line": 2, "character": 38}, "end": {"line": 2, "character": 39}}, "contents": {"value": "```lean\nn : ℕ\n```", "kind": "markdown"}}
{"character": ".", "row": 2, "column": 39, "range": {"start": {"line": 2, "character": 38}, "end": {"line": 2, "character": 46}}, "contents": {"value": "```lean\nℕ\n```", "kind": "markdown"}}
{"character": "g", "row": 2, "column": 40, "range": {"start": {"line": 2, "character": 40}, "end": {"line": 2, "character": 43}}, "contents": {"value": "```lean\nNat.gcd (m n : ℕ) : ℕ\n```\n***\nComputes the greatest common divisor of two natural numbers. The GCD of two natural numbers is the\nlargest natural number that evenly divides both.\n\nIn particular, the GCD of a number and `0` is the number itself.\n\nThis reference implementation via the Euclidean algorithm is overridden in both the kernel and the\ncompiler to efficiently evaluate using arbitrary-precision arithmetic. The definition provided here\nis the logical model.\n\nExamples:\n* `Nat.gcd 10 15 = 5`\n* `Nat.gcd 0 5 = 5`\n* `Nat.gcd 7 0 = 7`\n\n***\n*import Init.Data.Nat.Gcd*", "kind": "markdown"}}
{"character": "c", "row": 2, "column": 41, "range": {"start": {"line": 2, "character": 40}, "end": {"line": 2, "character": 43}}, "contents": {"value": "```lean\nNat.gcd (m n : ℕ) : ℕ\n```\n***\nComputes the greatest common divisor of two natural numbers. The GCD of two natural numbers is the\nlargest natural number that evenly divides both.\n\nIn particular, the GCD of a number and `0` is the number itself.\n\nThis reference implementation via the Euclidean algorithm is overridden in both the kernel and the\ncompiler to efficiently evaluate using arbitrary-precision arithmetic. The definition provided here\nis the logical model.\n\nExamples:\n* `Nat.gcd 10 15 = 5`\n* `Nat.gcd 0 5 = 5`\n* `Nat.gcd 7 0 = 7`\n\n***\n*import Init.Data.Nat.Gcd*", "kind": "markdown"}}
{"character": "d", "row": 2, "column": 42, "range": {"start": {"line": 2, "character": 40}, "end": {"line": 2, "character": 43}}, "contents": {"value": "```lean\nNat.gcd (m n : ℕ) : ℕ\n```\n***\nComputes the greatest common divisor of two natural numbers. The GCD of two natural numbers is the\nlargest natural number that evenly divides both.\n\nIn particular, the GCD of a number and `0` is the number itself.\n\nThis reference implementation via the Euclidean algorithm is overridden in both the kernel and the\ncompiler to efficiently evaluate using arbitrary-precision arithmetic. The definition provided here\nis the logical model.\n\nExamples:\n* `Nat.gcd 10 15 = 5`\n* `Nat.gcd 0 5 = 5`\n* `Nat.gcd 7 0 = 7`\n\n***\n*import Init.Data.Nat.Gcd*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 43, "range": {"start": {"line": 2, "character": 38}, "end": {"line": 2, "character": 46}}, "contents": {"value": "```lean\nℕ\n```", "kind": "markdown"}}
{"character": "4", "row": 2, "column": 44, "range": {"start": {"line": 2, "character": 44}, "end": {"line": 2, "character": 46}}, "contents": {"value": "```lean\n40 : ℕ\n```", "kind": "markdown"}}
{"character": "0", "row": 2, "column": 45, "range": {"start": {"line": 2, "character": 44}, "end": {"line": 2, "character": 46}}, "contents": {"value": "```lean\n40 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 46, "range": {"start": {"line": 2, "character": 38}, "end": {"line": 2, "character": 51}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "=", "row": 2, "column": 47, "range": {"start": {"line": 2, "character": 38}, "end": {"line": 2, "character": 51}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 48, "range": {"start": {"line": 2, "character": 38}, "end": {"line": 2, "character": 51}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "1", "row": 2, "column": 49, "range": {"start": {"line": 2, "character": 49}, "end": {"line": 2, "character": 51}}, "contents": {"value": "```lean\n10 : ℕ\n```", "kind": "markdown"}}
{"character": "0", "row": 2, "column": 50, "range": {"start": {"line": 2, "character": 49}, "end": {"line": 2, "character": 51}}, "contents": {"value": "```lean\n10 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 51, "range": {"start": {"line": 2, "character": 38}, "end": {"line": 2, "character": 68}}, "contents": {"value": "```lean\nProp\n```\n***\n`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.", "kind": "markdown"}}
{"character": "∧", "row": 2, "column": 52, "range": {"start": {"line": 2, "character": 38}, "end": {"line": 2, "character": 68}}, "contents": {"value": "```lean\nProp\n```\n***\n`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 53, "range": {"start": {"line": 2, "character": 38}, "end": {"line": 2, "character": 68}}, "contents": {"value": "```lean\nProp\n```\n***\n`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 54, "range": {"start": {"line": 2, "character": 54}, "end": {"line": 2, "character": 55}}, "contents": {"value": "```lean\nn : ℕ\n```", "kind": "markdown"}}
{"character": ".", "row": 2, "column": 55, "range": {"start": {"line": 2, "character": 54}, "end": {"line": 2, "character": 62}}, "contents": {"value": "```lean\nℕ\n```", "kind": "markdown"}}
{"character": "l", "row": 2, "column": 56, "range": {"start": {"line": 2, "character": 56}, "end": {"line": 2, "character": 59}}, "contents": {"value": "```lean\nNat.lcm (m n : ℕ) : ℕ\n```\n***\nThe least common multiple of `m` and `n` is the smallest natural number that's evenly divisible by\nboth `m` and `n`. Returns `0` if either `m` or `n` is `0`.\n\nExamples:\n * `Nat.lcm 9 6 = 18`\n * `Nat.lcm 9 3 = 9`\n * `Nat.lcm 0 3 = 0`\n * `Nat.lcm 3 0 = 0`\n\n***\n*import Init.Data.Nat.Lcm*", "kind": "markdown"}}
{"character": "c", "row": 2, "column": 57, "range": {"start": {"line": 2, "character": 56}, "end": {"line": 2, "character": 59}}, "contents": {"value": "```lean\nNat.lcm (m n : ℕ) : ℕ\n```\n***\nThe least common multiple of `m` and `n` is the smallest natural number that's evenly divisible by\nboth `m` and `n`. Returns `0` if either `m` or `n` is `0`.\n\nExamples:\n * `Nat.lcm 9 6 = 18`\n * `Nat.lcm 9 3 = 9`\n * `Nat.lcm 0 3 = 0`\n * `Nat.lcm 3 0 = 0`\n\n***\n*import Init.Data.Nat.Lcm*", "kind": "markdown"}}
{"character": "m", "row": 2, "column": 58, "range": {"start": {"line": 2, "character": 56}, "end": {"line": 2, "character": 59}}, "contents": {"value": "```lean\nNat.lcm (m n : ℕ) : ℕ\n```\n***\nThe least common multiple of `m` and `n` is the smallest natural number that's evenly divisible by\nboth `m` and `n`. Returns `0` if either `m` or `n` is `0`.\n\nExamples:\n * `Nat.lcm 9 6 = 18`\n * `Nat.lcm 9 3 = 9`\n * `Nat.lcm 0 3 = 0`\n * `Nat.lcm 3 0 = 0`\n\n***\n*import Init.Data.Nat.Lcm*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 59, "range": {"start": {"line": 2, "character": 54}, "end": {"line": 2, "character": 62}}, "contents": {"value": "```lean\nℕ\n```", "kind": "markdown"}}
{"character": "4", "row": 2, "column": 60, "range": {"start": {"line": 2, "character": 60}, "end": {"line": 2, "character": 62}}, "contents": {"value": "```lean\n40 : ℕ\n```", "kind": "markdown"}}
{"character": "0", "row": 2, "column": 61, "range": {"start": {"line": 2, "character": 60}, "end": {"line": 2, "character": 62}}, "contents": {"value": "```lean\n40 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 62, "range": {"start": {"line": 2, "character": 54}, "end": {"line": 2, "character": 68}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "=", "row": 2, "column": 63, "range": {"start": {"line": 2, "character": 54}, "end": {"line": 2, "character": 68}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 64, "range": {"start": {"line": 2, "character": 54}, "end": {"line": 2, "character": 68}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "2", "row": 2, "column": 65, "range": {"start": {"line": 2, "character": 65}, "end": {"line": 2, "character": 68}}, "contents": {"value": "```lean\n280 : ℕ\n```", "kind": "markdown"}}
{"character": "8", "row": 2, "column": 66, "range": {"start": {"line": 2, "character": 65}, "end": {"line": 2, "character": 68}}, "contents": {"value": "```lean\n280 : ℕ\n```", "kind": "markdown"}}
{"character": "0", "row": 2, "column": 67, "range": {"start": {"line": 2, "character": 65}, "end": {"line": 2, "character": 68}}, "contents": {"value": "```lean\n280 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 68, "range": {"start": {"line": 2, "character": 38}, "end": {"line": 2, "character": 77}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "→", "row": 2, "column": 69, "range": {"start": {"line": 2, "character": 38}, "end": {"line": 2, "character": 77}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 70, "range": {"start": {"line": 2, "character": 38}, "end": {"line": 2, "character": 77}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 71, "range": {"start": {"line": 2, "character": 71}, "end": {"line": 2, "character": 72}}, "contents": {"value": "```lean\nn : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 72, "range": {"start": {"line": 2, "character": 71}, "end": {"line": 2, "character": 77}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "=", "row": 2, "column": 73, "range": {"start": {"line": 2, "character": 71}, "end": {"line": 2, "character": 77}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 74, "range": {"start": {"line": 2, "character": 71}, "end": {"line": 2, "character": 77}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "7", "row": 2, "column": 75, "range": {"start": {"line": 2, "character": 75}, "end": {"line": 2, "character": 77}}, "contents": {"value": "```lean\n70 : ℕ\n```", "kind": "markdown"}}
{"character": "0", "row": 2, "column": 76, "range": {"start": {"line": 2, "character": 75}, "end": {"line": 2, "character": 77}}, "contents": {"value": "```lean\n70 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 77}
{"character": ":", "row": 2, "column": 78}
{"character": "=", "row": 2, "column": 79}
{"character": " ", "row": 2, "column": 80}
{"character": "b", "row": 2, "column": 81, "range": {"start": {"line": 2, "character": 81}, "end": {"line": 2, "character": 89}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 82, "range": {"start": {"line": 2, "character": 81}, "end": {"line": 2, "character": 89}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 83, "range": {"start": {"line": 2, "character": 81}, "end": {"line": 2, "character": 89}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": "s", "row": 2, "column": 84, "range": {"start": {"line": 2, "character": 84}, "end": {"line": 2, "character": 89}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 85, "range": {"start": {"line": 2, "character": 84}, "end": {"line": 2, "character": 89}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 86, "range": {"start": {"line": 2, "character": 84}, "end": {"line": 2, "character": 89}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 87, "range": {"start": {"line": 2, "character": 84}, "end": {"line": 2, "character": 89}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 88, "range": {"start": {"line": 2, "character": 84}, "end": {"line": 2, "character": 89}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
