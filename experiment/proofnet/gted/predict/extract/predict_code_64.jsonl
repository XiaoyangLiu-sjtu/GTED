{"character": "t", "row": 0, "column": 0}
{"character": "h", "row": 0, "column": 1}
{"character": "e", "row": 0, "column": 2}
{"character": "o", "row": 0, "column": 3}
{"character": "r", "row": 0, "column": 4}
{"character": "e", "row": 0, "column": 5}
{"character": "m", "row": 0, "column": 6}
{"character": " ", "row": 0, "column": 7}
{"character": "t", "row": 0, "column": 8}
{"character": "m", "row": 0, "column": 9}
{"character": "_", "row": 0, "column": 10}
{"character": "n", "row": 0, "column": 11}
{"character": "a", "row": 0, "column": 12}
{"character": "m", "row": 0, "column": 13}
{"character": "e", "row": 0, "column": 14}
{"character": " ", "row": 0, "column": 15}
{"character": ":", "row": 0, "column": 16}
{"character": " ", "row": 0, "column": 17}
{"character": "∀", "row": 0, "column": 18}
{"character": " ", "row": 0, "column": 19}
{"character": "{", "row": 0, "column": 20, "range": {"start": {"line": 0, "character": 20}, "end": {"line": 0, "character": 36}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": "i", "row": 0, "column": 21, "range": {"start": {"line": 0, "character": 21}, "end": {"line": 0, "character": 24}}, "contents": {"value": "```lean\nidx : Type u_2\n```", "kind": "markdown"}}
{"character": "d", "row": 0, "column": 22, "range": {"start": {"line": 0, "character": 21}, "end": {"line": 0, "character": 24}}, "contents": {"value": "```lean\nidx : Type u_2\n```", "kind": "markdown"}}
{"character": "x", "row": 0, "column": 23, "range": {"start": {"line": 0, "character": 21}, "end": {"line": 0, "character": 24}}, "contents": {"value": "```lean\nidx : Type u_2\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 24}
{"character": ":", "row": 0, "column": 25, "range": {"start": {"line": 0, "character": 20}, "end": {"line": 0, "character": 36}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 26}
{"character": "T", "row": 0, "column": 27, "range": {"start": {"line": 0, "character": 27}, "end": {"line": 0, "character": 35}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "y", "row": 0, "column": 28, "range": {"start": {"line": 0, "character": 27}, "end": {"line": 0, "character": 35}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "p", "row": 0, "column": 29, "range": {"start": {"line": 0, "character": 27}, "end": {"line": 0, "character": 35}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "e", "row": 0, "column": 30, "range": {"start": {"line": 0, "character": 27}, "end": {"line": 0, "character": 35}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 31, "range": {"start": {"line": 0, "character": 27}, "end": {"line": 0, "character": 35}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "u", "row": 0, "column": 32, "range": {"start": {"line": 0, "character": 27}, "end": {"line": 0, "character": 35}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "_", "row": 0, "column": 33, "range": {"start": {"line": 0, "character": 27}, "end": {"line": 0, "character": 35}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "2", "row": 0, "column": 34, "range": {"start": {"line": 0, "character": 27}, "end": {"line": 0, "character": 35}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "}", "row": 0, "column": 35, "range": {"start": {"line": 0, "character": 20}, "end": {"line": 0, "character": 36}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 36}
{"character": "{", "row": 0, "column": 37, "range": {"start": {"line": 0, "character": 37}, "end": {"line": 0, "character": 46}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": "X", "row": 0, "column": 38, "range": {"start": {"line": 0, "character": 38}, "end": {"line": 0, "character": 39}}, "contents": {"value": "```lean\nX : idx\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 39}
{"character": ":", "row": 0, "column": 40, "range": {"start": {"line": 0, "character": 37}, "end": {"line": 0, "character": 46}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 41}
{"character": "i", "row": 0, "column": 42, "range": {"start": {"line": 0, "character": 42}, "end": {"line": 0, "character": 45}}, "contents": {"value": "```lean\nidx : Type u_2\n```", "kind": "markdown"}}
{"character": "d", "row": 0, "column": 43, "range": {"start": {"line": 0, "character": 42}, "end": {"line": 0, "character": 45}}, "contents": {"value": "```lean\nidx : Type u_2\n```", "kind": "markdown"}}
{"character": "x", "row": 0, "column": 44, "range": {"start": {"line": 0, "character": 42}, "end": {"line": 0, "character": 45}}, "contents": {"value": "```lean\nidx : Type u_2\n```", "kind": "markdown"}}
{"character": "}", "row": 0, "column": 45, "range": {"start": {"line": 0, "character": 37}, "end": {"line": 0, "character": 46}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 46}
{"character": "{", "row": 0, "column": 47, "range": {"start": {"line": 0, "character": 47}, "end": {"line": 0, "character": 61}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": "R", "row": 0, "column": 48, "range": {"start": {"line": 0, "character": 48}, "end": {"line": 0, "character": 49}}, "contents": {"value": "```lean\nR : Type u_1\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 49}
{"character": ":", "row": 0, "column": 50, "range": {"start": {"line": 0, "character": 47}, "end": {"line": 0, "character": 61}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 51}
{"character": "T", "row": 0, "column": 52, "range": {"start": {"line": 0, "character": 52}, "end": {"line": 0, "character": 60}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "y", "row": 0, "column": 53, "range": {"start": {"line": 0, "character": 52}, "end": {"line": 0, "character": 60}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "p", "row": 0, "column": 54, "range": {"start": {"line": 0, "character": 52}, "end": {"line": 0, "character": 60}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "e", "row": 0, "column": 55, "range": {"start": {"line": 0, "character": 52}, "end": {"line": 0, "character": 60}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 56, "range": {"start": {"line": 0, "character": 52}, "end": {"line": 0, "character": 60}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "u", "row": 0, "column": 57, "range": {"start": {"line": 0, "character": 52}, "end": {"line": 0, "character": 60}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "_", "row": 0, "column": 58, "range": {"start": {"line": 0, "character": 52}, "end": {"line": 0, "character": 60}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "1", "row": 0, "column": 59, "range": {"start": {"line": 0, "character": 52}, "end": {"line": 0, "character": 60}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "}", "row": 0, "column": 60, "range": {"start": {"line": 0, "character": 47}, "end": {"line": 0, "character": 61}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 61}
{"character": "[", "row": 0, "column": 62, "range": {"start": {"line": 0, "character": 62}, "end": {"line": 0, "character": 81}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "i", "row": 0, "column": 63, "range": {"start": {"line": 0, "character": 62}, "end": {"line": 0, "character": 81}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "n", "row": 0, "column": 64, "range": {"start": {"line": 0, "character": 62}, "end": {"line": 0, "character": 81}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "s", "row": 0, "column": 65, "range": {"start": {"line": 0, "character": 62}, "end": {"line": 0, "character": 81}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "t", "row": 0, "column": 66, "range": {"start": {"line": 0, "character": 62}, "end": {"line": 0, "character": 81}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 67}
{"character": ":", "row": 0, "column": 68, "range": {"start": {"line": 0, "character": 62}, "end": {"line": 0, "character": 81}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 69}
{"character": "S", "row": 0, "column": 70, "range": {"start": {"line": 0, "character": 70}, "end": {"line": 0, "character": 78}}, "contents": {"value": "```lean\nSemiring : ?m.10\n```", "kind": "markdown"}}
{"character": "e", "row": 0, "column": 71, "range": {"start": {"line": 0, "character": 70}, "end": {"line": 0, "character": 78}}, "contents": {"value": "```lean\nSemiring : ?m.10\n```", "kind": "markdown"}}
{"character": "m", "row": 0, "column": 72, "range": {"start": {"line": 0, "character": 70}, "end": {"line": 0, "character": 78}}, "contents": {"value": "```lean\nSemiring : ?m.10\n```", "kind": "markdown"}}
{"character": "i", "row": 0, "column": 73, "range": {"start": {"line": 0, "character": 70}, "end": {"line": 0, "character": 78}}, "contents": {"value": "```lean\nSemiring : ?m.10\n```", "kind": "markdown"}}
{"character": "r", "row": 0, "column": 74, "range": {"start": {"line": 0, "character": 70}, "end": {"line": 0, "character": 78}}, "contents": {"value": "```lean\nSemiring : ?m.10\n```", "kind": "markdown"}}
{"character": "i", "row": 0, "column": 75, "range": {"start": {"line": 0, "character": 70}, "end": {"line": 0, "character": 78}}, "contents": {"value": "```lean\nSemiring : ?m.10\n```", "kind": "markdown"}}
{"character": "n", "row": 0, "column": 76, "range": {"start": {"line": 0, "character": 70}, "end": {"line": 0, "character": 78}}, "contents": {"value": "```lean\nSemiring : ?m.10\n```", "kind": "markdown"}}
{"character": "g", "row": 0, "column": 77, "range": {"start": {"line": 0, "character": 70}, "end": {"line": 0, "character": 78}}, "contents": {"value": "```lean\nSemiring : ?m.10\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 78}
{"character": "R", "row": 0, "column": 79, "range": {"start": {"line": 0, "character": 62}, "end": {"line": 0, "character": 81}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "]", "row": 0, "column": 80, "range": {"start": {"line": 0, "character": 62}, "end": {"line": 0, "character": 81}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 81}
{"character": "{", "row": 0, "column": 82, "range": {"start": {"line": 0, "character": 82}, "end": {"line": 0, "character": 92}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": "p", "row": 0, "column": 83, "range": {"start": {"line": 0, "character": 82}, "end": {"line": 0, "character": 92}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 84}
{"character": ":", "row": 0, "column": 85, "range": {"start": {"line": 0, "character": 82}, "end": {"line": 0, "character": 92}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 86}
{"character": "R", "row": 0, "column": 87, "range": {"start": {"line": 0, "character": 87}, "end": {"line": 0, "character": 91}}, "contents": {"value": "The syntax `arr[i]` gets the `i`'th element of the collection `arr`. If there\nare proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]` in identifiers is `getElem`.", "kind": "markdown"}}
{"character": "[", "row": 0, "column": 88, "range": {"start": {"line": 0, "character": 87}, "end": {"line": 0, "character": 91}}, "contents": {"value": "The syntax `arr[i]` gets the `i`'th element of the collection `arr`. If there\nare proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]` in identifiers is `getElem`.", "kind": "markdown"}}
{"character": "X", "row": 0, "column": 89, "range": {"start": {"line": 0, "character": 87}, "end": {"line": 0, "character": 91}}, "contents": {"value": "The syntax `arr[i]` gets the `i`'th element of the collection `arr`. If there\nare proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]` in identifiers is `getElem`.", "kind": "markdown"}}
{"character": "]", "row": 0, "column": 90, "range": {"start": {"line": 0, "character": 87}, "end": {"line": 0, "character": 91}}, "contents": {"value": "The syntax `arr[i]` gets the `i`'th element of the collection `arr`. If there\nare proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]` in identifiers is `getElem`.", "kind": "markdown"}}
{"character": "}", "row": 0, "column": 91, "range": {"start": {"line": 0, "character": 82}, "end": {"line": 0, "character": 92}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": ",", "row": 0, "column": 92}
{"character": " ", "row": 0, "column": 93}
{"character": "p", "row": 0, "column": 94, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 95}
{"character": "∈", "row": 0, "column": 96, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 97}
{"character": "n", "row": 0, "column": 98, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "o", "row": 0, "column": 99, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "n", "row": 0, "column": 100, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "Z", "row": 0, "column": 101, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "e", "row": 0, "column": 102, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "r", "row": 0, "column": 103, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "o", "row": 0, "column": 104, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "D", "row": 0, "column": 105, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "i", "row": 0, "column": 106, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "v", "row": 0, "column": 107, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "i", "row": 0, "column": 108, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "s", "row": 0, "column": 109, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "o", "row": 0, "column": 110, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "r", "row": 0, "column": 111, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "s", "row": 0, "column": 112, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 113}
{"character": "R", "row": 0, "column": 114, "range": {"start": {"line": 0, "character": 114}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The syntax `arr[i]` gets the `i`'th element of the collection `arr`. If there\nare proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]` in identifiers is `getElem`.", "kind": "markdown"}}
{"character": "[", "row": 0, "column": 115, "range": {"start": {"line": 0, "character": 114}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The syntax `arr[i]` gets the `i`'th element of the collection `arr`. If there\nare proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]` in identifiers is `getElem`.", "kind": "markdown"}}
{"character": "X", "row": 0, "column": 116, "range": {"start": {"line": 0, "character": 114}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The syntax `arr[i]` gets the `i`'th element of the collection `arr`. If there\nare proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]` in identifiers is `getElem`.", "kind": "markdown"}}
{"character": "]", "row": 0, "column": 117, "range": {"start": {"line": 0, "character": 114}, "end": {"line": 0, "character": 118}}, "contents": {"value": "The syntax `arr[i]` gets the `i`'th element of the collection `arr`. If there\nare proof side conditions to the application, they will be automatically\ninferred by the `get_elem_tactic` tactic.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `xs[i]` in identifiers is `getElem`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 118}
{"character": "↔", "row": 0, "column": 119, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 138}}, "contents": {"value": "If and only if, or logical bi-implication. `a ↔ b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `↔` in identifiers is `iff`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 120}
{"character": "p", "row": 0, "column": 121, "range": {"start": {"line": 0, "character": 121}, "end": {"line": 0, "character": 126}}, "contents": {"value": "The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 122}
{"character": "=", "row": 0, "column": 123, "range": {"start": {"line": 0, "character": 121}, "end": {"line": 0, "character": 126}}, "contents": {"value": "The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 124}
{"character": "0", "row": 0, "column": 125, "range": {"start": {"line": 0, "character": 121}, "end": {"line": 0, "character": 126}}, "contents": {"value": "The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 126}
{"character": "∨", "row": 0, "column": 127, "range": {"start": {"line": 0, "character": 121}, "end": {"line": 0, "character": 138}}, "contents": {"value": "`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∨` in identifiers is `or`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 128}
{"character": "s", "row": 0, "column": 129, "range": {"start": {"line": 0, "character": 129}, "end": {"line": 0, "character": 134}}, "contents": {"value": "The `sorry` term is a temporary placeholder for a missing proof or value.\n\nThe syntax is intended for stubbing-out incomplete parts of a value or proof while still having a syntactically correct skeleton.\nLean will give a warning whenever a declaration uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a declaration depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n\n\"Go to definition\" on `sorry` in the Infoview will go to the source position where it was introduced, if such information is available.\n\nEach `sorry` is guaranteed to be unique, so for example the following fails:\n```lean\nexample : (sorry : Nat) = sorry := rfl -- fails\n```\n\nSee also the `sorry` tactic, which is short for `exact sorry`.\n", "kind": "markdown"}}
{"character": "o", "row": 0, "column": 130, "range": {"start": {"line": 0, "character": 129}, "end": {"line": 0, "character": 134}}, "contents": {"value": "The `sorry` term is a temporary placeholder for a missing proof or value.\n\nThe syntax is intended for stubbing-out incomplete parts of a value or proof while still having a syntactically correct skeleton.\nLean will give a warning whenever a declaration uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a declaration depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n\n\"Go to definition\" on `sorry` in the Infoview will go to the source position where it was introduced, if such information is available.\n\nEach `sorry` is guaranteed to be unique, so for example the following fails:\n```lean\nexample : (sorry : Nat) = sorry := rfl -- fails\n```\n\nSee also the `sorry` tactic, which is short for `exact sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 0, "column": 131, "range": {"start": {"line": 0, "character": 129}, "end": {"line": 0, "character": 134}}, "contents": {"value": "The `sorry` term is a temporary placeholder for a missing proof or value.\n\nThe syntax is intended for stubbing-out incomplete parts of a value or proof while still having a syntactically correct skeleton.\nLean will give a warning whenever a declaration uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a declaration depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n\n\"Go to definition\" on `sorry` in the Infoview will go to the source position where it was introduced, if such information is available.\n\nEach `sorry` is guaranteed to be unique, so for example the following fails:\n```lean\nexample : (sorry : Nat) = sorry := rfl -- fails\n```\n\nSee also the `sorry` tactic, which is short for `exact sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 0, "column": 132, "range": {"start": {"line": 0, "character": 129}, "end": {"line": 0, "character": 134}}, "contents": {"value": "The `sorry` term is a temporary placeholder for a missing proof or value.\n\nThe syntax is intended for stubbing-out incomplete parts of a value or proof while still having a syntactically correct skeleton.\nLean will give a warning whenever a declaration uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a declaration depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n\n\"Go to definition\" on `sorry` in the Infoview will go to the source position where it was introduced, if such information is available.\n\nEach `sorry` is guaranteed to be unique, so for example the following fails:\n```lean\nexample : (sorry : Nat) = sorry := rfl -- fails\n```\n\nSee also the `sorry` tactic, which is short for `exact sorry`.\n", "kind": "markdown"}}
{"character": "y", "row": 0, "column": 133, "range": {"start": {"line": 0, "character": 129}, "end": {"line": 0, "character": 134}}, "contents": {"value": "The `sorry` term is a temporary placeholder for a missing proof or value.\n\nThe syntax is intended for stubbing-out incomplete parts of a value or proof while still having a syntactically correct skeleton.\nLean will give a warning whenever a declaration uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a declaration depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n\n\"Go to definition\" on `sorry` in the Infoview will go to the source position where it was introduced, if such information is available.\n\nEach `sorry` is guaranteed to be unique, so for example the following fails:\n```lean\nexample : (sorry : Nat) = sorry := rfl -- fails\n```\n\nSee also the `sorry` tactic, which is short for `exact sorry`.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 134}
{"character": "≠", "row": 0, "column": 135, "range": {"start": {"line": 0, "character": 129}, "end": {"line": 0, "character": 138}}, "contents": {"value": "`a ≠ b`, or `Ne a b` is defined as `¬ (a = b)` or `a = b → False`,\nand asserts that `a` and `b` are not equal.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≠` in identifiers is `ne`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 136}
{"character": "0", "row": 0, "column": 137, "range": {"start": {"line": 0, "character": 129}, "end": {"line": 0, "character": 138}}, "contents": {"value": "`a ≠ b`, or `Ne a b` is defined as `¬ (a = b)` or `a = b → False`,\nand asserts that `a` and `b` are not equal.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≠` in identifiers is `ne`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 138}
{"character": ":", "row": 0, "column": 139}
{"character": "=", "row": 0, "column": 140}
{"character": " ", "row": 0, "column": 141}
{"character": "b", "row": 0, "column": 142, "range": {"start": {"line": 0, "character": 142}, "end": {"line": 0, "character": 150}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": "y", "row": 0, "column": 143, "range": {"start": {"line": 0, "character": 142}, "end": {"line": 0, "character": 150}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 144}
{"character": "s", "row": 0, "column": 145, "range": {"start": {"line": 0, "character": 145}, "end": {"line": 0, "character": 150}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "o", "row": 0, "column": 146, "range": {"start": {"line": 0, "character": 145}, "end": {"line": 0, "character": 150}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 0, "column": 147, "range": {"start": {"line": 0, "character": 145}, "end": {"line": 0, "character": 150}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 0, "column": 148, "range": {"start": {"line": 0, "character": 145}, "end": {"line": 0, "character": 150}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "y", "row": 0, "column": 149, "range": {"start": {"line": 0, "character": 145}, "end": {"line": 0, "character": 150}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
