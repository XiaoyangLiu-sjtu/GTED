{"character": "t", "row": 0, "column": 0}
{"character": "h", "row": 0, "column": 1}
{"character": "e", "row": 0, "column": 2}
{"character": "o", "row": 0, "column": 3}
{"character": "r", "row": 0, "column": 4}
{"character": "e", "row": 0, "column": 5}
{"character": "m", "row": 0, "column": 6}
{"character": " ", "row": 0, "column": 7}
{"character": "t", "row": 0, "column": 8}
{"character": "m", "row": 0, "column": 9}
{"character": "_", "row": 0, "column": 10}
{"character": "n", "row": 0, "column": 11}
{"character": "a", "row": 0, "column": 12}
{"character": "m", "row": 0, "column": 13}
{"character": "e", "row": 0, "column": 14}
{"character": ".", "row": 0, "column": 15}
{"character": "{", "row": 0, "column": 16}
{"character": "u", "row": 0, "column": 17}
{"character": "_", "row": 0, "column": 18}
{"character": "1", "row": 0, "column": 19}
{"character": "}", "row": 0, "column": 20}
{"character": " ", "row": 0, "column": 21}
{"character": "{", "row": 0, "column": 22, "range": {"start": {"line": 0, "character": 22}, "end": {"line": 0, "character": 36}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": "G", "row": 0, "column": 23, "range": {"start": {"line": 0, "character": 23}, "end": {"line": 0, "character": 24}}, "contents": {"value": "```lean\nG : Type u_1\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 24}
{"character": ":", "row": 0, "column": 25, "range": {"start": {"line": 0, "character": 22}, "end": {"line": 0, "character": 36}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 26}
{"character": "T", "row": 0, "column": 27, "range": {"start": {"line": 0, "character": 27}, "end": {"line": 0, "character": 35}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "y", "row": 0, "column": 28, "range": {"start": {"line": 0, "character": 27}, "end": {"line": 0, "character": 35}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "p", "row": 0, "column": 29, "range": {"start": {"line": 0, "character": 27}, "end": {"line": 0, "character": 35}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "e", "row": 0, "column": 30, "range": {"start": {"line": 0, "character": 27}, "end": {"line": 0, "character": 35}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 31, "range": {"start": {"line": 0, "character": 27}, "end": {"line": 0, "character": 35}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "u", "row": 0, "column": 32, "range": {"start": {"line": 0, "character": 27}, "end": {"line": 0, "character": 35}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "_", "row": 0, "column": 33, "range": {"start": {"line": 0, "character": 27}, "end": {"line": 0, "character": 35}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "1", "row": 0, "column": 34, "range": {"start": {"line": 0, "character": 27}, "end": {"line": 0, "character": 35}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "}", "row": 0, "column": 35, "range": {"start": {"line": 0, "character": 22}, "end": {"line": 0, "character": 36}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 36}
{"character": "[", "row": 0, "column": 37, "range": {"start": {"line": 0, "character": 37}, "end": {"line": 0, "character": 46}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "G", "row": 0, "column": 38, "range": {"start": {"line": 0, "character": 37}, "end": {"line": 0, "character": 46}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "r", "row": 0, "column": 39, "range": {"start": {"line": 0, "character": 37}, "end": {"line": 0, "character": 46}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "o", "row": 0, "column": 40, "range": {"start": {"line": 0, "character": 37}, "end": {"line": 0, "character": 46}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "u", "row": 0, "column": 41, "range": {"start": {"line": 0, "character": 37}, "end": {"line": 0, "character": 46}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "p", "row": 0, "column": 42, "range": {"start": {"line": 0, "character": 37}, "end": {"line": 0, "character": 46}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 43}
{"character": "G", "row": 0, "column": 44, "range": {"start": {"line": 0, "character": 37}, "end": {"line": 0, "character": 46}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "]", "row": 0, "column": 45, "range": {"start": {"line": 0, "character": 37}, "end": {"line": 0, "character": 46}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 46}
{"character": "[", "row": 0, "column": 47, "range": {"start": {"line": 0, "character": 47}, "end": {"line": 0, "character": 57}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "F", "row": 0, "column": 48, "range": {"start": {"line": 0, "character": 47}, "end": {"line": 0, "character": 57}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "i", "row": 0, "column": 49, "range": {"start": {"line": 0, "character": 47}, "end": {"line": 0, "character": 57}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "n", "row": 0, "column": 50, "range": {"start": {"line": 0, "character": 47}, "end": {"line": 0, "character": 57}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "i", "row": 0, "column": 51, "range": {"start": {"line": 0, "character": 47}, "end": {"line": 0, "character": 57}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "t", "row": 0, "column": 52, "range": {"start": {"line": 0, "character": 47}, "end": {"line": 0, "character": 57}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "e", "row": 0, "column": 53, "range": {"start": {"line": 0, "character": 47}, "end": {"line": 0, "character": 57}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 54}
{"character": "G", "row": 0, "column": 55, "range": {"start": {"line": 0, "character": 47}, "end": {"line": 0, "character": 57}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "]", "row": 0, "column": 56, "range": {"start": {"line": 0, "character": 47}, "end": {"line": 0, "character": 57}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 57}
{"character": "(", "row": 0, "column": 58, "range": {"start": {"line": 0, "character": 58}, "end": {"line": 0, "character": 74}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "H", "row": 0, "column": 59, "range": {"start": {"line": 0, "character": 58}, "end": {"line": 0, "character": 74}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 60}
{"character": ":", "row": 0, "column": 61, "range": {"start": {"line": 0, "character": 58}, "end": {"line": 0, "character": 74}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 62}
{"character": "S", "row": 0, "column": 63, "range": {"start": {"line": 0, "character": 58}, "end": {"line": 0, "character": 74}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "u", "row": 0, "column": 64, "range": {"start": {"line": 0, "character": 58}, "end": {"line": 0, "character": 74}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "b", "row": 0, "column": 65, "range": {"start": {"line": 0, "character": 58}, "end": {"line": 0, "character": 74}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "g", "row": 0, "column": 66, "range": {"start": {"line": 0, "character": 58}, "end": {"line": 0, "character": 74}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "r", "row": 0, "column": 67, "range": {"start": {"line": 0, "character": 58}, "end": {"line": 0, "character": 74}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "o", "row": 0, "column": 68, "range": {"start": {"line": 0, "character": 58}, "end": {"line": 0, "character": 74}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "u", "row": 0, "column": 69, "range": {"start": {"line": 0, "character": 58}, "end": {"line": 0, "character": 74}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "p", "row": 0, "column": 70, "range": {"start": {"line": 0, "character": 58}, "end": {"line": 0, "character": 74}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 71}
{"character": "G", "row": 0, "column": 72, "range": {"start": {"line": 0, "character": 58}, "end": {"line": 0, "character": 74}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": ")", "row": 0, "column": 73, "range": {"start": {"line": 0, "character": 58}, "end": {"line": 0, "character": 74}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 74}
{"character": ":", "row": 0, "column": 75}
{"character": " ", "row": 0, "column": 76}
{"character": "H", "row": 0, "column": 77, "range": {"start": {"line": 0, "character": 77}, "end": {"line": 0, "character": 80}}, "contents": {"value": "The less-than relation: `x < y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `<` in identifiers is `lt`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 78}
{"character": "<", "row": 0, "column": 79, "range": {"start": {"line": 0, "character": 77}, "end": {"line": 0, "character": 80}}, "contents": {"value": "The less-than relation: `x < y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `<` in identifiers is `lt`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 80}
{"character": "⊤", "row": 0, "column": 81}
{"character": " ", "row": 0, "column": 82}
{"character": "→", "row": 0, "column": 83}
{"character": " ", "row": 0, "column": 84}
{"character": "∃", "row": 0, "column": 85}
{"character": " ", "row": 0, "column": 86}
{"character": "M", "row": 0, "column": 87}
{"character": ",", "row": 0, "column": 88}
{"character": " ", "row": 0, "column": 89}
{"character": "H", "row": 0, "column": 90}
{"character": " ", "row": 0, "column": 91}
{"character": "≤", "row": 0, "column": 92}
{"character": " ", "row": 0, "column": 93}
{"character": "M", "row": 0, "column": 94}
{"character": " ", "row": 0, "column": 95}
{"character": "∧", "row": 0, "column": 96}
{"character": " ", "row": 0, "column": 97}
{"character": "∀", "row": 0, "column": 98}
{"character": " ", "row": 0, "column": 99}
{"character": "(", "row": 0, "column": 100}
{"character": "K", "row": 0, "column": 101}
{"character": " ", "row": 0, "column": 102}
{"character": ":", "row": 0, "column": 103}
{"character": " ", "row": 0, "column": 104}
{"character": "S", "row": 0, "column": 105}
{"character": "u", "row": 0, "column": 106}
{"character": "b", "row": 0, "column": 107}
{"character": "g", "row": 0, "column": 108}
{"character": "r", "row": 0, "column": 109}
{"character": "o", "row": 0, "column": 110}
{"character": "u", "row": 0, "column": 111}
{"character": "p", "row": 0, "column": 112}
{"character": " ", "row": 0, "column": 113}
{"character": "G", "row": 0, "column": 114}
{"character": ")", "row": 0, "column": 115}
{"character": ",", "row": 0, "column": 116}
{"character": " ", "row": 0, "column": 117}
{"character": "H", "row": 0, "column": 118}
{"character": " ", "row": 0, "column": 119}
{"character": "≤", "row": 0, "column": 120}
{"character": " ", "row": 0, "column": 121}
{"character": "K", "row": 0, "column": 122}
{"character": " ", "row": 0, "column": 123}
{"character": "→", "row": 0, "column": 124}
{"character": " ", "row": 0, "column": 125}
{"character": "K", "row": 0, "column": 126}
{"character": " ", "row": 0, "column": 127}
{"character": "=", "row": 0, "column": 128}
{"character": " ", "row": 0, "column": 129}
{"character": "M", "row": 0, "column": 130}
{"character": " ", "row": 0, "column": 131}
{"character": "∨", "row": 0, "column": 132}
{"character": " ", "row": 0, "column": 133}
{"character": "K", "row": 0, "column": 134}
{"character": " ", "row": 0, "column": 135}
{"character": "=", "row": 0, "column": 136}
{"character": " ", "row": 0, "column": 137}
{"character": "⊤", "row": 0, "column": 138}
{"character": " ", "row": 0, "column": 139}
{"character": ":", "row": 0, "column": 140}
{"character": "=", "row": 0, "column": 141}
{"character": " ", "row": 0, "column": 142}
{"character": "b", "row": 0, "column": 143}
{"character": "y", "row": 0, "column": 144}
{"character": " ", "row": 0, "column": 145}
{"character": "s", "row": 0, "column": 146}
{"character": "o", "row": 0, "column": 147}
{"character": "r", "row": 0, "column": 148}
{"character": "r", "row": 0, "column": 149}
{"character": "y", "row": 0, "column": 150}
