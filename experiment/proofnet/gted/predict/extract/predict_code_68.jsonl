{"character": "i", "row": 0, "column": 0}
{"character": "m", "row": 0, "column": 1}
{"character": "p", "row": 0, "column": 2}
{"character": "o", "row": 0, "column": 3}
{"character": "r", "row": 0, "column": 4}
{"character": "t", "row": 0, "column": 5}
{"character": " ", "row": 0, "column": 6}
{"character": "M", "row": 0, "column": 7}
{"character": "a", "row": 0, "column": 8}
{"character": "t", "row": 0, "column": 9}
{"character": "h", "row": 0, "column": 10}
{"character": "l", "row": 0, "column": 11}
{"character": "i", "row": 0, "column": 12}
{"character": "b", "row": 0, "column": 13}
{"character": "t", "row": 1, "column": 0}
{"character": "h", "row": 1, "column": 1}
{"character": "e", "row": 1, "column": 2}
{"character": "o", "row": 1, "column": 3}
{"character": "r", "row": 1, "column": 4}
{"character": "e", "row": 1, "column": 5}
{"character": "m", "row": 1, "column": 6}
{"character": " ", "row": 1, "column": 7}
{"character": "t", "row": 1, "column": 8, "range": {"start": {"line": 1, "character": 8}, "end": {"line": 1, "character": 15}}, "contents": {"value": "```lean\ntm_name {q : ℕ} [Fact (Nat.Prime q)] (hq : ↑q ≡ 3 [ZMOD 4]) : IsField (ZMod (q ^ 2))\n```", "kind": "markdown"}}
{"character": "m", "row": 1, "column": 9, "range": {"start": {"line": 1, "character": 8}, "end": {"line": 1, "character": 15}}, "contents": {"value": "```lean\ntm_name {q : ℕ} [Fact (Nat.Prime q)] (hq : ↑q ≡ 3 [ZMOD 4]) : IsField (ZMod (q ^ 2))\n```", "kind": "markdown"}}
{"character": "_", "row": 1, "column": 10, "range": {"start": {"line": 1, "character": 8}, "end": {"line": 1, "character": 15}}, "contents": {"value": "```lean\ntm_name {q : ℕ} [Fact (Nat.Prime q)] (hq : ↑q ≡ 3 [ZMOD 4]) : IsField (ZMod (q ^ 2))\n```", "kind": "markdown"}}
{"character": "n", "row": 1, "column": 11, "range": {"start": {"line": 1, "character": 8}, "end": {"line": 1, "character": 15}}, "contents": {"value": "```lean\ntm_name {q : ℕ} [Fact (Nat.Prime q)] (hq : ↑q ≡ 3 [ZMOD 4]) : IsField (ZMod (q ^ 2))\n```", "kind": "markdown"}}
{"character": "a", "row": 1, "column": 12, "range": {"start": {"line": 1, "character": 8}, "end": {"line": 1, "character": 15}}, "contents": {"value": "```lean\ntm_name {q : ℕ} [Fact (Nat.Prime q)] (hq : ↑q ≡ 3 [ZMOD 4]) : IsField (ZMod (q ^ 2))\n```", "kind": "markdown"}}
{"character": "m", "row": 1, "column": 13, "range": {"start": {"line": 1, "character": 8}, "end": {"line": 1, "character": 15}}, "contents": {"value": "```lean\ntm_name {q : ℕ} [Fact (Nat.Prime q)] (hq : ↑q ≡ 3 [ZMOD 4]) : IsField (ZMod (q ^ 2))\n```", "kind": "markdown"}}
{"character": "e", "row": 1, "column": 14, "range": {"start": {"line": 1, "character": 8}, "end": {"line": 1, "character": 15}}, "contents": {"value": "```lean\ntm_name {q : ℕ} [Fact (Nat.Prime q)] (hq : ↑q ≡ 3 [ZMOD 4]) : IsField (ZMod (q ^ 2))\n```", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 15}
{"character": "{", "row": 1, "column": 16, "range": {"start": {"line": 1, "character": 16}, "end": {"line": 1, "character": 23}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": "q", "row": 1, "column": 17, "range": {"start": {"line": 1, "character": 17}, "end": {"line": 1, "character": 18}}, "contents": {"value": "```lean\nq : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 18}
{"character": ":", "row": 1, "column": 19, "range": {"start": {"line": 1, "character": 16}, "end": {"line": 1, "character": 23}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 20}
{"character": "ℕ", "row": 1, "column": 21, "range": {"start": {"line": 1, "character": 21}, "end": {"line": 1, "character": 22}}, "contents": {"value": "```lean\nNat : Type\n```\n***\nThe natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n\n***\n*import Init.Prelude*", "kind": "markdown"}}
{"character": "}", "row": 1, "column": 22, "range": {"start": {"line": 1, "character": 16}, "end": {"line": 1, "character": 23}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 23}
{"character": "[", "row": 1, "column": 24, "range": {"start": {"line": 1, "character": 24}, "end": {"line": 1, "character": 44}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "F", "row": 1, "column": 25, "range": {"start": {"line": 1, "character": 25}, "end": {"line": 1, "character": 29}}, "contents": {"value": "```lean\nFact (p : Prop) : Prop\n```\n***\nWrapper for adding elementary propositions to the type class systems.\nWarning: this can easily be abused. See the rest of this docstring for details.\n\nCertain propositions should not be treated as a class globally,\nbut sometimes it is very convenient to be able to use the type class system\nin specific circumstances.\n\nFor example, `ZMod p` is a field if and only if `p` is a prime number.\nIn order to be able to find this field instance automatically by type class search,\nwe have to turn `p.prime` into an instance implicit assumption.\n\nOn the other hand, making `Nat.prime` a class would require a major refactoring of the library,\nand it is questionable whether making `Nat.prime` a class is desirable at all.\nThe compromise is to add the assumption `[Fact p.prime]` to `ZMod.field`.\n\nIn particular, this class is not intended for turning the type class system\ninto an automated theorem prover for first order logic. \n***\n*import Mathlib.Logic.Basic*", "kind": "markdown"}}
{"character": "a", "row": 1, "column": 26, "range": {"start": {"line": 1, "character": 25}, "end": {"line": 1, "character": 29}}, "contents": {"value": "```lean\nFact (p : Prop) : Prop\n```\n***\nWrapper for adding elementary propositions to the type class systems.\nWarning: this can easily be abused. See the rest of this docstring for details.\n\nCertain propositions should not be treated as a class globally,\nbut sometimes it is very convenient to be able to use the type class system\nin specific circumstances.\n\nFor example, `ZMod p` is a field if and only if `p` is a prime number.\nIn order to be able to find this field instance automatically by type class search,\nwe have to turn `p.prime` into an instance implicit assumption.\n\nOn the other hand, making `Nat.prime` a class would require a major refactoring of the library,\nand it is questionable whether making `Nat.prime` a class is desirable at all.\nThe compromise is to add the assumption `[Fact p.prime]` to `ZMod.field`.\n\nIn particular, this class is not intended for turning the type class system\ninto an automated theorem prover for first order logic. \n***\n*import Mathlib.Logic.Basic*", "kind": "markdown"}}
{"character": "c", "row": 1, "column": 27, "range": {"start": {"line": 1, "character": 25}, "end": {"line": 1, "character": 29}}, "contents": {"value": "```lean\nFact (p : Prop) : Prop\n```\n***\nWrapper for adding elementary propositions to the type class systems.\nWarning: this can easily be abused. See the rest of this docstring for details.\n\nCertain propositions should not be treated as a class globally,\nbut sometimes it is very convenient to be able to use the type class system\nin specific circumstances.\n\nFor example, `ZMod p` is a field if and only if `p` is a prime number.\nIn order to be able to find this field instance automatically by type class search,\nwe have to turn `p.prime` into an instance implicit assumption.\n\nOn the other hand, making `Nat.prime` a class would require a major refactoring of the library,\nand it is questionable whether making `Nat.prime` a class is desirable at all.\nThe compromise is to add the assumption `[Fact p.prime]` to `ZMod.field`.\n\nIn particular, this class is not intended for turning the type class system\ninto an automated theorem prover for first order logic. \n***\n*import Mathlib.Logic.Basic*", "kind": "markdown"}}
{"character": "t", "row": 1, "column": 28, "range": {"start": {"line": 1, "character": 25}, "end": {"line": 1, "character": 29}}, "contents": {"value": "```lean\nFact (p : Prop) : Prop\n```\n***\nWrapper for adding elementary propositions to the type class systems.\nWarning: this can easily be abused. See the rest of this docstring for details.\n\nCertain propositions should not be treated as a class globally,\nbut sometimes it is very convenient to be able to use the type class system\nin specific circumstances.\n\nFor example, `ZMod p` is a field if and only if `p` is a prime number.\nIn order to be able to find this field instance automatically by type class search,\nwe have to turn `p.prime` into an instance implicit assumption.\n\nOn the other hand, making `Nat.prime` a class would require a major refactoring of the library,\nand it is questionable whether making `Nat.prime` a class is desirable at all.\nThe compromise is to add the assumption `[Fact p.prime]` to `ZMod.field`.\n\nIn particular, this class is not intended for turning the type class system\ninto an automated theorem prover for first order logic. \n***\n*import Mathlib.Logic.Basic*", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 29, "range": {"start": {"line": 1, "character": 25}, "end": {"line": 1, "character": 43}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "(", "row": 1, "column": 30, "range": {"start": {"line": 1, "character": 30}, "end": {"line": 1, "character": 43}}, "contents": {"value": "```lean\nProp\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "N", "row": 1, "column": 31, "range": {"start": {"line": 1, "character": 31}, "end": {"line": 1, "character": 40}}, "contents": {"value": "```lean\nNat.Prime (p : ℕ) : Prop\n```\n***\n`Nat.Prime p` means that `p` is a prime number, that is, a natural number\nat least 2 whose only divisors are `p` and `1`.\nThe theorem `Nat.prime_def` witnesses this description of a prime number. \n***\n*import Mathlib.Data.Nat.Prime.Defs*", "kind": "markdown"}}
{"character": "a", "row": 1, "column": 32, "range": {"start": {"line": 1, "character": 31}, "end": {"line": 1, "character": 40}}, "contents": {"value": "```lean\nNat.Prime (p : ℕ) : Prop\n```\n***\n`Nat.Prime p` means that `p` is a prime number, that is, a natural number\nat least 2 whose only divisors are `p` and `1`.\nThe theorem `Nat.prime_def` witnesses this description of a prime number. \n***\n*import Mathlib.Data.Nat.Prime.Defs*", "kind": "markdown"}}
{"character": "t", "row": 1, "column": 33, "range": {"start": {"line": 1, "character": 31}, "end": {"line": 1, "character": 40}}, "contents": {"value": "```lean\nNat.Prime (p : ℕ) : Prop\n```\n***\n`Nat.Prime p` means that `p` is a prime number, that is, a natural number\nat least 2 whose only divisors are `p` and `1`.\nThe theorem `Nat.prime_def` witnesses this description of a prime number. \n***\n*import Mathlib.Data.Nat.Prime.Defs*", "kind": "markdown"}}
{"character": ".", "row": 1, "column": 34, "range": {"start": {"line": 1, "character": 31}, "end": {"line": 1, "character": 40}}, "contents": {"value": "```lean\nNat.Prime (p : ℕ) : Prop\n```\n***\n`Nat.Prime p` means that `p` is a prime number, that is, a natural number\nat least 2 whose only divisors are `p` and `1`.\nThe theorem `Nat.prime_def` witnesses this description of a prime number. \n***\n*import Mathlib.Data.Nat.Prime.Defs*", "kind": "markdown"}}
{"character": "P", "row": 1, "column": 35, "range": {"start": {"line": 1, "character": 31}, "end": {"line": 1, "character": 40}}, "contents": {"value": "```lean\nNat.Prime (p : ℕ) : Prop\n```\n***\n`Nat.Prime p` means that `p` is a prime number, that is, a natural number\nat least 2 whose only divisors are `p` and `1`.\nThe theorem `Nat.prime_def` witnesses this description of a prime number. \n***\n*import Mathlib.Data.Nat.Prime.Defs*", "kind": "markdown"}}
{"character": "r", "row": 1, "column": 36, "range": {"start": {"line": 1, "character": 31}, "end": {"line": 1, "character": 40}}, "contents": {"value": "```lean\nNat.Prime (p : ℕ) : Prop\n```\n***\n`Nat.Prime p` means that `p` is a prime number, that is, a natural number\nat least 2 whose only divisors are `p` and `1`.\nThe theorem `Nat.prime_def` witnesses this description of a prime number. \n***\n*import Mathlib.Data.Nat.Prime.Defs*", "kind": "markdown"}}
{"character": "i", "row": 1, "column": 37, "range": {"start": {"line": 1, "character": 31}, "end": {"line": 1, "character": 40}}, "contents": {"value": "```lean\nNat.Prime (p : ℕ) : Prop\n```\n***\n`Nat.Prime p` means that `p` is a prime number, that is, a natural number\nat least 2 whose only divisors are `p` and `1`.\nThe theorem `Nat.prime_def` witnesses this description of a prime number. \n***\n*import Mathlib.Data.Nat.Prime.Defs*", "kind": "markdown"}}
{"character": "m", "row": 1, "column": 38, "range": {"start": {"line": 1, "character": 31}, "end": {"line": 1, "character": 40}}, "contents": {"value": "```lean\nNat.Prime (p : ℕ) : Prop\n```\n***\n`Nat.Prime p` means that `p` is a prime number, that is, a natural number\nat least 2 whose only divisors are `p` and `1`.\nThe theorem `Nat.prime_def` witnesses this description of a prime number. \n***\n*import Mathlib.Data.Nat.Prime.Defs*", "kind": "markdown"}}
{"character": "e", "row": 1, "column": 39, "range": {"start": {"line": 1, "character": 31}, "end": {"line": 1, "character": 40}}, "contents": {"value": "```lean\nNat.Prime (p : ℕ) : Prop\n```\n***\n`Nat.Prime p` means that `p` is a prime number, that is, a natural number\nat least 2 whose only divisors are `p` and `1`.\nThe theorem `Nat.prime_def` witnesses this description of a prime number. \n***\n*import Mathlib.Data.Nat.Prime.Defs*", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 40, "range": {"start": {"line": 1, "character": 31}, "end": {"line": 1, "character": 42}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "q", "row": 1, "column": 41, "range": {"start": {"line": 1, "character": 41}, "end": {"line": 1, "character": 42}}, "contents": {"value": "```lean\nq : ℕ\n```", "kind": "markdown"}}
{"character": ")", "row": 1, "column": 42, "range": {"start": {"line": 1, "character": 30}, "end": {"line": 1, "character": 43}}, "contents": {"value": "```lean\nProp\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "]", "row": 1, "column": 43, "range": {"start": {"line": 1, "character": 24}, "end": {"line": 1, "character": 44}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 44}
{"character": "(", "row": 1, "column": 45, "range": {"start": {"line": 1, "character": 45}, "end": {"line": 1, "character": 67}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "h", "row": 1, "column": 46, "range": {"start": {"line": 1, "character": 46}, "end": {"line": 1, "character": 48}}, "contents": {"value": "```lean\nhq : ↑q ≡ 3 [ZMOD 4]\n```", "kind": "markdown"}}
{"character": "q", "row": 1, "column": 47, "range": {"start": {"line": 1, "character": 46}, "end": {"line": 1, "character": 48}}, "contents": {"value": "```lean\nhq : ↑q ≡ 3 [ZMOD 4]\n```", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 48}
{"character": ":", "row": 1, "column": 49, "range": {"start": {"line": 1, "character": 45}, "end": {"line": 1, "character": 67}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 50}
{"character": "↑", "row": 1, "column": 51, "range": {"start": {"line": 1, "character": 51}, "end": {"line": 1, "character": 53}}, "contents": {"value": "```lean\nℤ\n```\n***\n`↑x` represents a coercion, which converts `x` of type `α` to type `β`, using\ntypeclasses to resolve a suitable conversion function. You can often leave the\n`↑` off entirely, since coercion is triggered implicitly whenever there is a\ntype error, but in ambiguous cases it can be useful to use `↑` to disambiguate\nbetween e.g. `↑x + ↑y` and `↑(x + y)`.\n", "kind": "markdown"}}
{"character": "q", "row": 1, "column": 52, "range": {"start": {"line": 1, "character": 52}, "end": {"line": 1, "character": 53}}, "contents": {"value": "```lean\nq : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 53, "range": {"start": {"line": 1, "character": 51}, "end": {"line": 1, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\n`a ≡ b [ZMOD n]` when `a % n = b % n`. ", "kind": "markdown"}}
{"character": "≡", "row": 1, "column": 54, "range": {"start": {"line": 1, "character": 51}, "end": {"line": 1, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\n`a ≡ b [ZMOD n]` when `a % n = b % n`. ", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 55, "range": {"start": {"line": 1, "character": 51}, "end": {"line": 1, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\n`a ≡ b [ZMOD n]` when `a % n = b % n`. ", "kind": "markdown"}}
{"character": "3", "row": 1, "column": 56, "range": {"start": {"line": 1, "character": 56}, "end": {"line": 1, "character": 57}}, "contents": {"value": "```lean\n3 : ℤ\n```", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 57, "range": {"start": {"line": 1, "character": 51}, "end": {"line": 1, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\n`a ≡ b [ZMOD n]` when `a % n = b % n`. ", "kind": "markdown"}}
{"character": "[", "row": 1, "column": 58, "range": {"start": {"line": 1, "character": 51}, "end": {"line": 1, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\n`a ≡ b [ZMOD n]` when `a % n = b % n`. ", "kind": "markdown"}}
{"character": "Z", "row": 1, "column": 59, "range": {"start": {"line": 1, "character": 51}, "end": {"line": 1, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\n`a ≡ b [ZMOD n]` when `a % n = b % n`. ", "kind": "markdown"}}
{"character": "M", "row": 1, "column": 60, "range": {"start": {"line": 1, "character": 51}, "end": {"line": 1, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\n`a ≡ b [ZMOD n]` when `a % n = b % n`. ", "kind": "markdown"}}
{"character": "O", "row": 1, "column": 61, "range": {"start": {"line": 1, "character": 51}, "end": {"line": 1, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\n`a ≡ b [ZMOD n]` when `a % n = b % n`. ", "kind": "markdown"}}
{"character": "D", "row": 1, "column": 62, "range": {"start": {"line": 1, "character": 51}, "end": {"line": 1, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\n`a ≡ b [ZMOD n]` when `a % n = b % n`. ", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 63, "range": {"start": {"line": 1, "character": 51}, "end": {"line": 1, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\n`a ≡ b [ZMOD n]` when `a % n = b % n`. ", "kind": "markdown"}}
{"character": "4", "row": 1, "column": 64, "range": {"start": {"line": 1, "character": 64}, "end": {"line": 1, "character": 65}}, "contents": {"value": "```lean\n4 : ℤ\n```", "kind": "markdown"}}
{"character": "]", "row": 1, "column": 65, "range": {"start": {"line": 1, "character": 51}, "end": {"line": 1, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\n`a ≡ b [ZMOD n]` when `a % n = b % n`. ", "kind": "markdown"}}
{"character": ")", "row": 1, "column": 66, "range": {"start": {"line": 1, "character": 45}, "end": {"line": 1, "character": 67}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 67}
{"character": ":", "row": 1, "column": 68, "range": {"start": {"line": 1, "character": 16}, "end": {"line": 1, "character": 92}}, "contents": {"value": "`declSig` matches the signature of a declaration with required type: a list of binders and then `: type` ", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 69}
{"character": "I", "row": 1, "column": 70, "range": {"start": {"line": 1, "character": 70}, "end": {"line": 1, "character": 77}}, "contents": {"value": "```lean\nIsField.{u} (R : Type u) [Semiring R] : Prop\n```\n***\nA predicate to express that a (semi)ring is a (semi)field.\n\nThis is mainly useful because such a predicate does not contain data,\nand can therefore be easily transported along ring isomorphisms.\nAdditionally, this is useful when trying to prove that\na particular ring structure extends to a (semi)field. \n***\n*import Mathlib.Algebra.Field.IsField*", "kind": "markdown"}}
{"character": "s", "row": 1, "column": 71, "range": {"start": {"line": 1, "character": 70}, "end": {"line": 1, "character": 77}}, "contents": {"value": "```lean\nIsField.{u} (R : Type u) [Semiring R] : Prop\n```\n***\nA predicate to express that a (semi)ring is a (semi)field.\n\nThis is mainly useful because such a predicate does not contain data,\nand can therefore be easily transported along ring isomorphisms.\nAdditionally, this is useful when trying to prove that\na particular ring structure extends to a (semi)field. \n***\n*import Mathlib.Algebra.Field.IsField*", "kind": "markdown"}}
{"character": "F", "row": 1, "column": 72, "range": {"start": {"line": 1, "character": 70}, "end": {"line": 1, "character": 77}}, "contents": {"value": "```lean\nIsField.{u} (R : Type u) [Semiring R] : Prop\n```\n***\nA predicate to express that a (semi)ring is a (semi)field.\n\nThis is mainly useful because such a predicate does not contain data,\nand can therefore be easily transported along ring isomorphisms.\nAdditionally, this is useful when trying to prove that\na particular ring structure extends to a (semi)field. \n***\n*import Mathlib.Algebra.Field.IsField*", "kind": "markdown"}}
{"character": "i", "row": 1, "column": 73, "range": {"start": {"line": 1, "character": 70}, "end": {"line": 1, "character": 77}}, "contents": {"value": "```lean\nIsField.{u} (R : Type u) [Semiring R] : Prop\n```\n***\nA predicate to express that a (semi)ring is a (semi)field.\n\nThis is mainly useful because such a predicate does not contain data,\nand can therefore be easily transported along ring isomorphisms.\nAdditionally, this is useful when trying to prove that\na particular ring structure extends to a (semi)field. \n***\n*import Mathlib.Algebra.Field.IsField*", "kind": "markdown"}}
{"character": "e", "row": 1, "column": 74, "range": {"start": {"line": 1, "character": 70}, "end": {"line": 1, "character": 77}}, "contents": {"value": "```lean\nIsField.{u} (R : Type u) [Semiring R] : Prop\n```\n***\nA predicate to express that a (semi)ring is a (semi)field.\n\nThis is mainly useful because such a predicate does not contain data,\nand can therefore be easily transported along ring isomorphisms.\nAdditionally, this is useful when trying to prove that\na particular ring structure extends to a (semi)field. \n***\n*import Mathlib.Algebra.Field.IsField*", "kind": "markdown"}}
{"character": "l", "row": 1, "column": 75, "range": {"start": {"line": 1, "character": 70}, "end": {"line": 1, "character": 77}}, "contents": {"value": "```lean\nIsField.{u} (R : Type u) [Semiring R] : Prop\n```\n***\nA predicate to express that a (semi)ring is a (semi)field.\n\nThis is mainly useful because such a predicate does not contain data,\nand can therefore be easily transported along ring isomorphisms.\nAdditionally, this is useful when trying to prove that\na particular ring structure extends to a (semi)field. \n***\n*import Mathlib.Algebra.Field.IsField*", "kind": "markdown"}}
{"character": "d", "row": 1, "column": 76, "range": {"start": {"line": 1, "character": 70}, "end": {"line": 1, "character": 77}}, "contents": {"value": "```lean\nIsField.{u} (R : Type u) [Semiring R] : Prop\n```\n***\nA predicate to express that a (semi)ring is a (semi)field.\n\nThis is mainly useful because such a predicate does not contain data,\nand can therefore be easily transported along ring isomorphisms.\nAdditionally, this is useful when trying to prove that\na particular ring structure extends to a (semi)field. \n***\n*import Mathlib.Algebra.Field.IsField*", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 77, "range": {"start": {"line": 1, "character": 70}, "end": {"line": 1, "character": 92}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "(", "row": 1, "column": 78, "range": {"start": {"line": 1, "character": 78}, "end": {"line": 1, "character": 92}}, "contents": {"value": "```lean\nType\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "Z", "row": 1, "column": 79, "range": {"start": {"line": 1, "character": 79}, "end": {"line": 1, "character": 83}}, "contents": {"value": "```lean\nZMod : ℕ → Type\n```\n***\nThe integers modulo `n : ℕ`. \n***\n*import Mathlib.Data.ZMod.Defs*", "kind": "markdown"}}
{"character": "M", "row": 1, "column": 80, "range": {"start": {"line": 1, "character": 79}, "end": {"line": 1, "character": 83}}, "contents": {"value": "```lean\nZMod : ℕ → Type\n```\n***\nThe integers modulo `n : ℕ`. \n***\n*import Mathlib.Data.ZMod.Defs*", "kind": "markdown"}}
{"character": "o", "row": 1, "column": 81, "range": {"start": {"line": 1, "character": 79}, "end": {"line": 1, "character": 83}}, "contents": {"value": "```lean\nZMod : ℕ → Type\n```\n***\nThe integers modulo `n : ℕ`. \n***\n*import Mathlib.Data.ZMod.Defs*", "kind": "markdown"}}
{"character": "d", "row": 1, "column": 82, "range": {"start": {"line": 1, "character": 79}, "end": {"line": 1, "character": 83}}, "contents": {"value": "```lean\nZMod : ℕ → Type\n```\n***\nThe integers modulo `n : ℕ`. \n***\n*import Mathlib.Data.ZMod.Defs*", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 83, "range": {"start": {"line": 1, "character": 79}, "end": {"line": 1, "character": 91}}, "contents": {"value": "```lean\nType\n```", "kind": "markdown"}}
{"character": "(", "row": 1, "column": 84, "range": {"start": {"line": 1, "character": 84}, "end": {"line": 1, "character": 91}}, "contents": {"value": "```lean\nℕ\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "q", "row": 1, "column": 85, "range": {"start": {"line": 1, "character": 85}, "end": {"line": 1, "character": 86}}, "contents": {"value": "```lean\nq : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 86, "range": {"start": {"line": 1, "character": 85}, "end": {"line": 1, "character": 90}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^` in identifiers is `pow`.", "kind": "markdown"}}
{"character": "^", "row": 1, "column": 87, "range": {"start": {"line": 1, "character": 85}, "end": {"line": 1, "character": 90}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^` in identifiers is `pow`.", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 88, "range": {"start": {"line": 1, "character": 85}, "end": {"line": 1, "character": 90}}, "contents": {"value": "```lean\nℕ\n```\n***\n`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^` in identifiers is `pow`.", "kind": "markdown"}}
{"character": "2", "row": 1, "column": 89, "range": {"start": {"line": 1, "character": 89}, "end": {"line": 1, "character": 90}}, "contents": {"value": "```lean\n2 : ℕ\n```", "kind": "markdown"}}
{"character": ")", "row": 1, "column": 90, "range": {"start": {"line": 1, "character": 84}, "end": {"line": 1, "character": 91}}, "contents": {"value": "```lean\nℕ\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": ")", "row": 1, "column": 91, "range": {"start": {"line": 1, "character": 78}, "end": {"line": 1, "character": 92}}, "contents": {"value": "```lean\nType\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 92}
{"character": ":", "row": 1, "column": 93}
{"character": "=", "row": 1, "column": 94}
{"character": " ", "row": 1, "column": 95}
{"character": "b", "row": 1, "column": 96, "range": {"start": {"line": 1, "character": 96}, "end": {"line": 1, "character": 104}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": "y", "row": 1, "column": 97, "range": {"start": {"line": 1, "character": 96}, "end": {"line": 1, "character": 104}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": " ", "row": 1, "column": 98, "range": {"start": {"line": 1, "character": 96}, "end": {"line": 1, "character": 104}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": "s", "row": 1, "column": 99, "range": {"start": {"line": 1, "character": 99}, "end": {"line": 1, "character": 104}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "o", "row": 1, "column": 100, "range": {"start": {"line": 1, "character": 99}, "end": {"line": 1, "character": 104}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 1, "column": 101, "range": {"start": {"line": 1, "character": 99}, "end": {"line": 1, "character": 104}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 1, "column": 102, "range": {"start": {"line": 1, "character": 99}, "end": {"line": 1, "character": 104}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "y", "row": 1, "column": 103, "range": {"start": {"line": 1, "character": 99}, "end": {"line": 1, "character": 104}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
