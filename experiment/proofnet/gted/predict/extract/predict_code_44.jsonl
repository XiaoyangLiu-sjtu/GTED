{"character": "i", "row": 0, "column": 0}
{"character": "m", "row": 0, "column": 1}
{"character": "p", "row": 0, "column": 2}
{"character": "o", "row": 0, "column": 3}
{"character": "r", "row": 0, "column": 4}
{"character": "t", "row": 0, "column": 5}
{"character": " ", "row": 0, "column": 6}
{"character": "M", "row": 0, "column": 7}
{"character": "a", "row": 0, "column": 8}
{"character": "t", "row": 0, "column": 9}
{"character": "h", "row": 0, "column": 10}
{"character": "l", "row": 0, "column": 11}
{"character": "i", "row": 0, "column": 12}
{"character": "b", "row": 0, "column": 13}
{"character": "t", "row": 2, "column": 0}
{"character": "h", "row": 2, "column": 1}
{"character": "e", "row": 2, "column": 2}
{"character": "o", "row": 2, "column": 3}
{"character": "r", "row": 2, "column": 4}
{"character": "e", "row": 2, "column": 5}
{"character": "m", "row": 2, "column": 6}
{"character": " ", "row": 2, "column": 7}
{"character": "c", "row": 2, "column": 8, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 19}}, "contents": {"value": "```lean\ncenter_prod.{u_1, u_2} {G : Type u_1} {H : Type u_2} [Group G] [Group H] :\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 9, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 19}}, "contents": {"value": "```lean\ncenter_prod.{u_1, u_2} {G : Type u_1} {H : Type u_2} [Group G] [Group H] :\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 10, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 19}}, "contents": {"value": "```lean\ncenter_prod.{u_1, u_2} {G : Type u_1} {H : Type u_2} [Group G] [Group H] :\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 11, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 19}}, "contents": {"value": "```lean\ncenter_prod.{u_1, u_2} {G : Type u_1} {H : Type u_2} [Group G] [Group H] :\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 12, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 19}}, "contents": {"value": "```lean\ncenter_prod.{u_1, u_2} {G : Type u_1} {H : Type u_2} [Group G] [Group H] :\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 13, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 19}}, "contents": {"value": "```lean\ncenter_prod.{u_1, u_2} {G : Type u_1} {H : Type u_2} [Group G] [Group H] :\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 14, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 19}}, "contents": {"value": "```lean\ncenter_prod.{u_1, u_2} {G : Type u_1} {H : Type u_2} [Group G] [Group H] :\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 15, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 19}}, "contents": {"value": "```lean\ncenter_prod.{u_1, u_2} {G : Type u_1} {H : Type u_2} [Group G] [Group H] :\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 16, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 19}}, "contents": {"value": "```lean\ncenter_prod.{u_1, u_2} {G : Type u_1} {H : Type u_2} [Group G] [Group H] :\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 17, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 19}}, "contents": {"value": "```lean\ncenter_prod.{u_1, u_2} {G : Type u_1} {H : Type u_2} [Group G] [Group H] :\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```", "kind": "markdown"}}
{"character": "d", "row": 2, "column": 18, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 19}}, "contents": {"value": "```lean\ncenter_prod.{u_1, u_2} {G : Type u_1} {H : Type u_2} [Group G] [Group H] :\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```", "kind": "markdown"}}
{"character": ".", "row": 2, "column": 19, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\ncenter_prod : ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "{", "row": 2, "column": 20, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\ncenter_prod : ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 21, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\ncenter_prod : ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 22, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\ncenter_prod : ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "1", "row": 2, "column": 23, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\ncenter_prod : ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": ",", "row": 2, "column": 24, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\ncenter_prod : ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 25, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\ncenter_prod : ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 26, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\ncenter_prod : ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 27, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\ncenter_prod : ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "2", "row": 2, "column": 28, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\ncenter_prod : ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "}", "row": 2, "column": 29, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\ncenter_prod : ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G × H) = (Subgroup.center G).prod (Subgroup.center H)\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 30}
{"character": "{", "row": 2, "column": 31, "range": {"start": {"line": 2, "character": 31}, "end": {"line": 2, "character": 45}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": "G", "row": 2, "column": 32, "range": {"start": {"line": 2, "character": 32}, "end": {"line": 2, "character": 33}}, "contents": {"value": "```lean\nG : Type u_1\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 33}
{"character": ":", "row": 2, "column": 34, "range": {"start": {"line": 2, "character": 31}, "end": {"line": 2, "character": 45}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 35}
{"character": "T", "row": 2, "column": 36, "range": {"start": {"line": 2, "character": 36}, "end": {"line": 2, "character": 44}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 37, "range": {"start": {"line": 2, "character": 36}, "end": {"line": 2, "character": 44}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 38, "range": {"start": {"line": 2, "character": 36}, "end": {"line": 2, "character": 44}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 39, "range": {"start": {"line": 2, "character": 36}, "end": {"line": 2, "character": 44}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 40, "range": {"start": {"line": 2, "character": 36}, "end": {"line": 2, "character": 44}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 41, "range": {"start": {"line": 2, "character": 36}, "end": {"line": 2, "character": 44}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 42, "range": {"start": {"line": 2, "character": 36}, "end": {"line": 2, "character": 44}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "1", "row": 2, "column": 43, "range": {"start": {"line": 2, "character": 36}, "end": {"line": 2, "character": 44}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "}", "row": 2, "column": 44, "range": {"start": {"line": 2, "character": 31}, "end": {"line": 2, "character": 45}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 45}
{"character": "{", "row": 2, "column": 46, "range": {"start": {"line": 2, "character": 46}, "end": {"line": 2, "character": 60}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": "H", "row": 2, "column": 47, "range": {"start": {"line": 2, "character": 47}, "end": {"line": 2, "character": 48}}, "contents": {"value": "```lean\nH : Type u_2\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 48}
{"character": ":", "row": 2, "column": 49, "range": {"start": {"line": 2, "character": 46}, "end": {"line": 2, "character": 60}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 50}
{"character": "T", "row": 2, "column": 51, "range": {"start": {"line": 2, "character": 51}, "end": {"line": 2, "character": 59}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 52, "range": {"start": {"line": 2, "character": 51}, "end": {"line": 2, "character": 59}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 53, "range": {"start": {"line": 2, "character": 51}, "end": {"line": 2, "character": 59}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 54, "range": {"start": {"line": 2, "character": 51}, "end": {"line": 2, "character": 59}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 55, "range": {"start": {"line": 2, "character": 51}, "end": {"line": 2, "character": 59}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 56, "range": {"start": {"line": 2, "character": 51}, "end": {"line": 2, "character": 59}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 57, "range": {"start": {"line": 2, "character": 51}, "end": {"line": 2, "character": 59}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "2", "row": 2, "column": 58, "range": {"start": {"line": 2, "character": 51}, "end": {"line": 2, "character": 59}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "}", "row": 2, "column": 59, "range": {"start": {"line": 2, "character": 46}, "end": {"line": 2, "character": 60}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 60}
{"character": "[", "row": 2, "column": 61, "range": {"start": {"line": 2, "character": 61}, "end": {"line": 2, "character": 70}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "G", "row": 2, "column": 62, "range": {"start": {"line": 2, "character": 62}, "end": {"line": 2, "character": 67}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 63, "range": {"start": {"line": 2, "character": 62}, "end": {"line": 2, "character": 67}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 64, "range": {"start": {"line": 2, "character": 62}, "end": {"line": 2, "character": 67}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 65, "range": {"start": {"line": 2, "character": 62}, "end": {"line": 2, "character": 67}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 66, "range": {"start": {"line": 2, "character": 62}, "end": {"line": 2, "character": 67}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 67, "range": {"start": {"line": 2, "character": 62}, "end": {"line": 2, "character": 69}}, "contents": {"value": "```lean\nType u_1\n```", "kind": "markdown"}}
{"character": "G", "row": 2, "column": 68, "range": {"start": {"line": 2, "character": 68}, "end": {"line": 2, "character": 69}}, "contents": {"value": "```lean\nG : Type u_1\n```", "kind": "markdown"}}
{"character": "]", "row": 2, "column": 69, "range": {"start": {"line": 2, "character": 61}, "end": {"line": 2, "character": 70}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 70}
{"character": "[", "row": 2, "column": 71, "range": {"start": {"line": 2, "character": 71}, "end": {"line": 2, "character": 80}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "G", "row": 2, "column": 72, "range": {"start": {"line": 2, "character": 72}, "end": {"line": 2, "character": 77}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 73, "range": {"start": {"line": 2, "character": 72}, "end": {"line": 2, "character": 77}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 74, "range": {"start": {"line": 2, "character": 72}, "end": {"line": 2, "character": 77}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 75, "range": {"start": {"line": 2, "character": 72}, "end": {"line": 2, "character": 77}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 76, "range": {"start": {"line": 2, "character": 72}, "end": {"line": 2, "character": 77}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 77, "range": {"start": {"line": 2, "character": 72}, "end": {"line": 2, "character": 79}}, "contents": {"value": "```lean\nType u_2\n```", "kind": "markdown"}}
{"character": "H", "row": 2, "column": 78, "range": {"start": {"line": 2, "character": 78}, "end": {"line": 2, "character": 79}}, "contents": {"value": "```lean\nH : Type u_2\n```", "kind": "markdown"}}
{"character": "]", "row": 2, "column": 79, "range": {"start": {"line": 2, "character": 71}, "end": {"line": 2, "character": 80}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 80}
{"character": ":", "row": 2, "column": 81, "range": {"start": {"line": 2, "character": 31}, "end": {"line": 2, "character": 153}}, "contents": {"value": "`declSig` matches the signature of a declaration with required type: a list of binders and then `: type` ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 82}
{"character": "S", "row": 2, "column": 83, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 98}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 84, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 98}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "b", "row": 2, "column": 85, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 98}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "g", "row": 2, "column": 86, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 98}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 87, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 98}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 88, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 98}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 89, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 98}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 90, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 98}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": ".", "row": 2, "column": 91, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 98}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "c", "row": 2, "column": 92, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 98}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 93, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 98}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 94, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 98}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 95, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 98}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 96, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 98}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 97, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 98}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 98, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 106}}, "contents": {"value": "```lean\nSubgroup (G × H)\n```", "kind": "markdown"}}
{"character": "(", "row": 2, "column": 99, "range": {"start": {"line": 2, "character": 99}, "end": {"line": 2, "character": 106}}, "contents": {"value": "```lean\nType (max u_1 u_2)\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "G", "row": 2, "column": 100, "range": {"start": {"line": 2, "character": 100}, "end": {"line": 2, "character": 101}}, "contents": {"value": "```lean\nG : Type u_1\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 101, "range": {"start": {"line": 2, "character": 100}, "end": {"line": 2, "character": 105}}, "contents": {"value": "```lean\nType (max u_1 u_2)\n```\n***\nThe product type, usually written `α × β`. Product types are also called pair or tuple types.\nElements of this type are pairs in which the first element is an `α` and the second element is a\n`β`.\n\nProducts nest to the right, so `(x, y, z) : α × β × γ` is equivalent to `(x, (y, z)) : α × (β × γ)`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `×` in identifiers is `Prod`.", "kind": "markdown"}}
{"character": "×", "row": 2, "column": 102, "range": {"start": {"line": 2, "character": 100}, "end": {"line": 2, "character": 105}}, "contents": {"value": "```lean\nType (max u_1 u_2)\n```\n***\nThe product type, usually written `α × β`. Product types are also called pair or tuple types.\nElements of this type are pairs in which the first element is an `α` and the second element is a\n`β`.\n\nProducts nest to the right, so `(x, y, z) : α × β × γ` is equivalent to `(x, (y, z)) : α × (β × γ)`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `×` in identifiers is `Prod`.", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 103, "range": {"start": {"line": 2, "character": 100}, "end": {"line": 2, "character": 105}}, "contents": {"value": "```lean\nType (max u_1 u_2)\n```\n***\nThe product type, usually written `α × β`. Product types are also called pair or tuple types.\nElements of this type are pairs in which the first element is an `α` and the second element is a\n`β`.\n\nProducts nest to the right, so `(x, y, z) : α × β × γ` is equivalent to `(x, (y, z)) : α × (β × γ)`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `×` in identifiers is `Prod`.", "kind": "markdown"}}
{"character": "H", "row": 2, "column": 104, "range": {"start": {"line": 2, "character": 104}, "end": {"line": 2, "character": 105}}, "contents": {"value": "```lean\nH : Type u_2\n```", "kind": "markdown"}}
{"character": ")", "row": 2, "column": 105, "range": {"start": {"line": 2, "character": 99}, "end": {"line": 2, "character": 106}}, "contents": {"value": "```lean\nType (max u_1 u_2)\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 106, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 153}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "=", "row": 2, "column": 107, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 153}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 108, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 153}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "(", "row": 2, "column": 109, "range": {"start": {"line": 2, "character": 109}, "end": {"line": 2, "character": 128}}, "contents": {"value": "```lean\nSubgroup G\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "S", "row": 2, "column": 110, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 125}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 111, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 125}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "b", "row": 2, "column": 112, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 125}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "g", "row": 2, "column": 113, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 125}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 114, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 125}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 115, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 125}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 116, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 125}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 117, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 125}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": ".", "row": 2, "column": 118, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 125}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "c", "row": 2, "column": 119, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 125}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 120, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 125}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 121, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 125}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 122, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 125}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 123, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 125}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 124, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 125}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 125, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 127}}, "contents": {"value": "```lean\nSubgroup G\n```", "kind": "markdown"}}
{"character": "G", "row": 2, "column": 126, "range": {"start": {"line": 2, "character": 126}, "end": {"line": 2, "character": 127}}, "contents": {"value": "```lean\nG : Type u_1\n```", "kind": "markdown"}}
{"character": ")", "row": 2, "column": 127, "range": {"start": {"line": 2, "character": 109}, "end": {"line": 2, "character": 128}}, "contents": {"value": "```lean\nSubgroup G\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": ".", "row": 2, "column": 128, "range": {"start": {"line": 2, "character": 109}, "end": {"line": 2, "character": 133}}, "contents": {"value": "The *extended field notation* `e.f` is roughly short for `T.f e` where `T` is the type of `e`.\nMore precisely,\n* if `e` is of a function type, `e.f` is translated to `Function.f (p := e)`\n  where `p` is the first explicit parameter of function type\n* if `e` is of a named type `T ...` and there is a declaration `T.f` (possibly from `export`),\n  `e.f` is translated to `T.f (p := e)` where `p` is the first explicit parameter of type `T ...`\n* otherwise, if `e` is of a structure type,\n  the above is repeated for every base type of the structure.\n\nThe field index notation `e.i`, where `i` is a positive number,\nis short for accessing the `i`-th field (1-indexed) of `e` if it is of a structure type. ", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 129, "range": {"start": {"line": 2, "character": 129}, "end": {"line": 2, "character": 133}}, "contents": {"value": "```lean\nSubgroup.prod.{u_1, u_5} {G : Type u_1} [Group G] {N : Type u_5} [Group N] (H : Subgroup G) (K : Subgroup N) :\n  Subgroup (G × N)\n```\n***\nGiven `Subgroup`s `H`, `K` of groups `G`, `N` respectively, `H × K` as a subgroup of `G × N`. \n***\n*import Mathlib.Algebra.Group.Subgroup.Basic*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 130, "range": {"start": {"line": 2, "character": 129}, "end": {"line": 2, "character": 133}}, "contents": {"value": "```lean\nSubgroup.prod.{u_1, u_5} {G : Type u_1} [Group G] {N : Type u_5} [Group N] (H : Subgroup G) (K : Subgroup N) :\n  Subgroup (G × N)\n```\n***\nGiven `Subgroup`s `H`, `K` of groups `G`, `N` respectively, `H × K` as a subgroup of `G × N`. \n***\n*import Mathlib.Algebra.Group.Subgroup.Basic*", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 131, "range": {"start": {"line": 2, "character": 129}, "end": {"line": 2, "character": 133}}, "contents": {"value": "```lean\nSubgroup.prod.{u_1, u_5} {G : Type u_1} [Group G] {N : Type u_5} [Group N] (H : Subgroup G) (K : Subgroup N) :\n  Subgroup (G × N)\n```\n***\nGiven `Subgroup`s `H`, `K` of groups `G`, `N` respectively, `H × K` as a subgroup of `G × N`. \n***\n*import Mathlib.Algebra.Group.Subgroup.Basic*", "kind": "markdown"}}
{"character": "d", "row": 2, "column": 132, "range": {"start": {"line": 2, "character": 129}, "end": {"line": 2, "character": 133}}, "contents": {"value": "```lean\nSubgroup.prod.{u_1, u_5} {G : Type u_1} [Group G] {N : Type u_5} [Group N] (H : Subgroup G) (K : Subgroup N) :\n  Subgroup (G × N)\n```\n***\nGiven `Subgroup`s `H`, `K` of groups `G`, `N` respectively, `H × K` as a subgroup of `G × N`. \n***\n*import Mathlib.Algebra.Group.Subgroup.Basic*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 133, "range": {"start": {"line": 2, "character": 109}, "end": {"line": 2, "character": 153}}, "contents": {"value": "```lean\nSubgroup (G × H)\n```", "kind": "markdown"}}
{"character": "(", "row": 2, "column": 134, "range": {"start": {"line": 2, "character": 134}, "end": {"line": 2, "character": 153}}, "contents": {"value": "```lean\nSubgroup H\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "S", "row": 2, "column": 135, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 136, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "b", "row": 2, "column": 137, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "g", "row": 2, "column": 138, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 139, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 140, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 141, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 142, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": ".", "row": 2, "column": 143, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "c", "row": 2, "column": 144, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 145, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 146, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 147, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 148, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 149, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.center.{u_1} (G : Type u_1) [Group G] : Subgroup G\n```\n***\nThe center of a group `G` is the set of elements that commute with everything in `G` \n***\n*import Mathlib.GroupTheory.Subgroup.Center*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 150, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 152}}, "contents": {"value": "```lean\nSubgroup H\n```", "kind": "markdown"}}
{"character": "H", "row": 2, "column": 151, "range": {"start": {"line": 2, "character": 151}, "end": {"line": 2, "character": 152}}, "contents": {"value": "```lean\nH : Type u_2\n```", "kind": "markdown"}}
{"character": ")", "row": 2, "column": 152, "range": {"start": {"line": 2, "character": 134}, "end": {"line": 2, "character": 153}}, "contents": {"value": "```lean\nSubgroup H\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 153}
{"character": ":", "row": 2, "column": 154}
{"character": "=", "row": 2, "column": 155}
{"character": " ", "row": 2, "column": 156}
{"character": "b", "row": 2, "column": 157, "range": {"start": {"line": 2, "character": 157}, "end": {"line": 2, "character": 165}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 158, "range": {"start": {"line": 2, "character": 157}, "end": {"line": 2, "character": 165}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 159, "range": {"start": {"line": 2, "character": 157}, "end": {"line": 2, "character": 165}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": "s", "row": 2, "column": 160, "range": {"start": {"line": 2, "character": 160}, "end": {"line": 2, "character": 165}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 161, "range": {"start": {"line": 2, "character": 160}, "end": {"line": 2, "character": 165}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 162, "range": {"start": {"line": 2, "character": 160}, "end": {"line": 2, "character": 165}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 163, "range": {"start": {"line": 2, "character": 160}, "end": {"line": 2, "character": 165}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 164, "range": {"start": {"line": 2, "character": 160}, "end": {"line": 2, "character": 165}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
