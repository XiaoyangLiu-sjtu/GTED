{"character": "i", "row": 0, "column": 0}
{"character": "m", "row": 0, "column": 1}
{"character": "p", "row": 0, "column": 2}
{"character": "o", "row": 0, "column": 3}
{"character": "r", "row": 0, "column": 4}
{"character": "t", "row": 0, "column": 5}
{"character": " ", "row": 0, "column": 6}
{"character": "M", "row": 0, "column": 7}
{"character": "a", "row": 0, "column": 8}
{"character": "t", "row": 0, "column": 9}
{"character": "h", "row": 0, "column": 10}
{"character": "l", "row": 0, "column": 11}
{"character": "i", "row": 0, "column": 12}
{"character": "b", "row": 0, "column": 13}
{"character": "t", "row": 2, "column": 0}
{"character": "h", "row": 2, "column": 1}
{"character": "e", "row": 2, "column": 2}
{"character": "o", "row": 2, "column": 3}
{"character": "r", "row": 2, "column": 4}
{"character": "e", "row": 2, "column": 5}
{"character": "m", "row": 2, "column": 6}
{"character": " ", "row": 2, "column": 7}
{"character": "z", "row": 2, "column": 8, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": "s", "row": 2, "column": 9, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": "q", "row": 2, "column": 10, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 11, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 12, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": "d", "row": 2, "column": 13, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 14, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": "i", "row": 2, "column": 15, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 16, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 17, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 18, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": "d", "row": 2, "column": 19, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 20, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": "c", "row": 2, "column": 21, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": "i", "row": 2, "column": 22, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": "b", "row": 2, "column": 23, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": "l", "row": 2, "column": 24, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 25, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 26}}, "contents": {"value": "```lean\nzsqrtd_irreducible {n : ℤ} (hn : Squarefree n) (h : 3 < n) : Irreducible 2\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 26}
{"character": "{", "row": 2, "column": 27, "range": {"start": {"line": 2, "character": 27}, "end": {"line": 2, "character": 34}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 28, "range": {"start": {"line": 2, "character": 28}, "end": {"line": 2, "character": 29}}, "contents": {"value": "```lean\nn : ℤ\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 29}
{"character": ":", "row": 2, "column": 30, "range": {"start": {"line": 2, "character": 27}, "end": {"line": 2, "character": 34}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 31}
{"character": "ℤ", "row": 2, "column": 32, "range": {"start": {"line": 2, "character": 32}, "end": {"line": 2, "character": 33}}, "contents": {"value": "```lean\nInt : Type\n```\n***\nThe integers.\n\nThis type is special-cased by the compiler and overridden with an efficient implementation. The\nruntime has a special representation for `Int` that stores “small” signed numbers directly, while\nlarger numbers use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)). A “small number” is an integer that can be encoded with one fewer bits\nthan the platform's pointer size (i.e. 63 bits on 64-bit architectures and 31 bits on 32-bit\narchitectures).\n\n***\n*import Init.Data.Int.Basic*", "kind": "markdown"}}
{"character": "}", "row": 2, "column": 33, "range": {"start": {"line": 2, "character": 27}, "end": {"line": 2, "character": 34}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 34}
{"character": "(", "row": 2, "column": 35, "range": {"start": {"line": 2, "character": 35}, "end": {"line": 2, "character": 54}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "h", "row": 2, "column": 36, "range": {"start": {"line": 2, "character": 36}, "end": {"line": 2, "character": 38}}, "contents": {"value": "```lean\nhn : Squarefree n\n```", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 37, "range": {"start": {"line": 2, "character": 36}, "end": {"line": 2, "character": 38}}, "contents": {"value": "```lean\nhn : Squarefree n\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 38}
{"character": ":", "row": 2, "column": 39, "range": {"start": {"line": 2, "character": 35}, "end": {"line": 2, "character": 54}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 40}
{"character": "S", "row": 2, "column": 41, "range": {"start": {"line": 2, "character": 41}, "end": {"line": 2, "character": 51}}, "contents": {"value": "```lean\nSquarefree.{u_1} {R : Type u_1} [Monoid R] (r : R) : Prop\n```\n***\nAn element of a monoid is squarefree if the only squares that\ndivide it are the squares of units. \n***\n*import Mathlib.Algebra.Squarefree.Basic*", "kind": "markdown"}}
{"character": "q", "row": 2, "column": 42, "range": {"start": {"line": 2, "character": 41}, "end": {"line": 2, "character": 51}}, "contents": {"value": "```lean\nSquarefree.{u_1} {R : Type u_1} [Monoid R] (r : R) : Prop\n```\n***\nAn element of a monoid is squarefree if the only squares that\ndivide it are the squares of units. \n***\n*import Mathlib.Algebra.Squarefree.Basic*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 43, "range": {"start": {"line": 2, "character": 41}, "end": {"line": 2, "character": 51}}, "contents": {"value": "```lean\nSquarefree.{u_1} {R : Type u_1} [Monoid R] (r : R) : Prop\n```\n***\nAn element of a monoid is squarefree if the only squares that\ndivide it are the squares of units. \n***\n*import Mathlib.Algebra.Squarefree.Basic*", "kind": "markdown"}}
{"character": "a", "row": 2, "column": 44, "range": {"start": {"line": 2, "character": 41}, "end": {"line": 2, "character": 51}}, "contents": {"value": "```lean\nSquarefree.{u_1} {R : Type u_1} [Monoid R] (r : R) : Prop\n```\n***\nAn element of a monoid is squarefree if the only squares that\ndivide it are the squares of units. \n***\n*import Mathlib.Algebra.Squarefree.Basic*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 45, "range": {"start": {"line": 2, "character": 41}, "end": {"line": 2, "character": 51}}, "contents": {"value": "```lean\nSquarefree.{u_1} {R : Type u_1} [Monoid R] (r : R) : Prop\n```\n***\nAn element of a monoid is squarefree if the only squares that\ndivide it are the squares of units. \n***\n*import Mathlib.Algebra.Squarefree.Basic*", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 46, "range": {"start": {"line": 2, "character": 41}, "end": {"line": 2, "character": 51}}, "contents": {"value": "```lean\nSquarefree.{u_1} {R : Type u_1} [Monoid R] (r : R) : Prop\n```\n***\nAn element of a monoid is squarefree if the only squares that\ndivide it are the squares of units. \n***\n*import Mathlib.Algebra.Squarefree.Basic*", "kind": "markdown"}}
{"character": "f", "row": 2, "column": 47, "range": {"start": {"line": 2, "character": 41}, "end": {"line": 2, "character": 51}}, "contents": {"value": "```lean\nSquarefree.{u_1} {R : Type u_1} [Monoid R] (r : R) : Prop\n```\n***\nAn element of a monoid is squarefree if the only squares that\ndivide it are the squares of units. \n***\n*import Mathlib.Algebra.Squarefree.Basic*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 48, "range": {"start": {"line": 2, "character": 41}, "end": {"line": 2, "character": 51}}, "contents": {"value": "```lean\nSquarefree.{u_1} {R : Type u_1} [Monoid R] (r : R) : Prop\n```\n***\nAn element of a monoid is squarefree if the only squares that\ndivide it are the squares of units. \n***\n*import Mathlib.Algebra.Squarefree.Basic*", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 49, "range": {"start": {"line": 2, "character": 41}, "end": {"line": 2, "character": 51}}, "contents": {"value": "```lean\nSquarefree.{u_1} {R : Type u_1} [Monoid R] (r : R) : Prop\n```\n***\nAn element of a monoid is squarefree if the only squares that\ndivide it are the squares of units. \n***\n*import Mathlib.Algebra.Squarefree.Basic*", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 50, "range": {"start": {"line": 2, "character": 41}, "end": {"line": 2, "character": 51}}, "contents": {"value": "```lean\nSquarefree.{u_1} {R : Type u_1} [Monoid R] (r : R) : Prop\n```\n***\nAn element of a monoid is squarefree if the only squares that\ndivide it are the squares of units. \n***\n*import Mathlib.Algebra.Squarefree.Basic*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 51, "range": {"start": {"line": 2, "character": 41}, "end": {"line": 2, "character": 53}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 52, "range": {"start": {"line": 2, "character": 52}, "end": {"line": 2, "character": 53}}, "contents": {"value": "```lean\nn : ℤ\n```", "kind": "markdown"}}
{"character": ")", "row": 2, "column": 53, "range": {"start": {"line": 2, "character": 35}, "end": {"line": 2, "character": 54}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 54}
{"character": "(", "row": 2, "column": 55, "range": {"start": {"line": 2, "character": 55}, "end": {"line": 2, "character": 66}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "h", "row": 2, "column": 56, "range": {"start": {"line": 2, "character": 56}, "end": {"line": 2, "character": 57}}, "contents": {"value": "```lean\nh : 3 < n\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 57}
{"character": ":", "row": 2, "column": 58, "range": {"start": {"line": 2, "character": 55}, "end": {"line": 2, "character": 66}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 59}
{"character": "3", "row": 2, "column": 60, "range": {"start": {"line": 2, "character": 60}, "end": {"line": 2, "character": 61}}, "contents": {"value": "```lean\n3 : ℤ\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 61, "range": {"start": {"line": 2, "character": 60}, "end": {"line": 2, "character": 65}}, "contents": {"value": "```lean\nProp\n```\n***\nThe less-than relation: `x < y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `<` in identifiers is `lt`.", "kind": "markdown"}}
{"character": "<", "row": 2, "column": 62, "range": {"start": {"line": 2, "character": 60}, "end": {"line": 2, "character": 65}}, "contents": {"value": "```lean\nProp\n```\n***\nThe less-than relation: `x < y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `<` in identifiers is `lt`.", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 63, "range": {"start": {"line": 2, "character": 60}, "end": {"line": 2, "character": 65}}, "contents": {"value": "```lean\nProp\n```\n***\nThe less-than relation: `x < y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `<` in identifiers is `lt`.", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 64, "range": {"start": {"line": 2, "character": 64}, "end": {"line": 2, "character": 65}}, "contents": {"value": "```lean\nn : ℤ\n```", "kind": "markdown"}}
{"character": ")", "row": 2, "column": 65, "range": {"start": {"line": 2, "character": 55}, "end": {"line": 2, "character": 66}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 66}
{"character": ":", "row": 2, "column": 67, "range": {"start": {"line": 2, "character": 27}, "end": {"line": 2, "character": 82}}, "contents": {"value": "`declSig` matches the signature of a declaration with required type: a list of binders and then `: type` ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 68}
{"character": "I", "row": 2, "column": 69, "range": {"start": {"line": 2, "character": 69}, "end": {"line": 2, "character": 80}}, "contents": {"value": "```lean\nIrreducible.{u_1} {M : Type u_1} [Monoid M] (p : M) : Prop\n```\n***\n`Irreducible p` states that `p` is non-unit and only factors into units.\n\nWe explicitly avoid stating that `p` is non-zero, this would require a semiring. Assuming only a\nmonoid allows us to reuse irreducible for associated elements.\n\n***\n*import Mathlib.Algebra.Prime.Defs*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 70, "range": {"start": {"line": 2, "character": 69}, "end": {"line": 2, "character": 80}}, "contents": {"value": "```lean\nIrreducible.{u_1} {M : Type u_1} [Monoid M] (p : M) : Prop\n```\n***\n`Irreducible p` states that `p` is non-unit and only factors into units.\n\nWe explicitly avoid stating that `p` is non-zero, this would require a semiring. Assuming only a\nmonoid allows us to reuse irreducible for associated elements.\n\n***\n*import Mathlib.Algebra.Prime.Defs*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 71, "range": {"start": {"line": 2, "character": 69}, "end": {"line": 2, "character": 80}}, "contents": {"value": "```lean\nIrreducible.{u_1} {M : Type u_1} [Monoid M] (p : M) : Prop\n```\n***\n`Irreducible p` states that `p` is non-unit and only factors into units.\n\nWe explicitly avoid stating that `p` is non-zero, this would require a semiring. Assuming only a\nmonoid allows us to reuse irreducible for associated elements.\n\n***\n*import Mathlib.Algebra.Prime.Defs*", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 72, "range": {"start": {"line": 2, "character": 69}, "end": {"line": 2, "character": 80}}, "contents": {"value": "```lean\nIrreducible.{u_1} {M : Type u_1} [Monoid M] (p : M) : Prop\n```\n***\n`Irreducible p` states that `p` is non-unit and only factors into units.\n\nWe explicitly avoid stating that `p` is non-zero, this would require a semiring. Assuming only a\nmonoid allows us to reuse irreducible for associated elements.\n\n***\n*import Mathlib.Algebra.Prime.Defs*", "kind": "markdown"}}
{"character": "d", "row": 2, "column": 73, "range": {"start": {"line": 2, "character": 69}, "end": {"line": 2, "character": 80}}, "contents": {"value": "```lean\nIrreducible.{u_1} {M : Type u_1} [Monoid M] (p : M) : Prop\n```\n***\n`Irreducible p` states that `p` is non-unit and only factors into units.\n\nWe explicitly avoid stating that `p` is non-zero, this would require a semiring. Assuming only a\nmonoid allows us to reuse irreducible for associated elements.\n\n***\n*import Mathlib.Algebra.Prime.Defs*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 74, "range": {"start": {"line": 2, "character": 69}, "end": {"line": 2, "character": 80}}, "contents": {"value": "```lean\nIrreducible.{u_1} {M : Type u_1} [Monoid M] (p : M) : Prop\n```\n***\n`Irreducible p` states that `p` is non-unit and only factors into units.\n\nWe explicitly avoid stating that `p` is non-zero, this would require a semiring. Assuming only a\nmonoid allows us to reuse irreducible for associated elements.\n\n***\n*import Mathlib.Algebra.Prime.Defs*", "kind": "markdown"}}
{"character": "c", "row": 2, "column": 75, "range": {"start": {"line": 2, "character": 69}, "end": {"line": 2, "character": 80}}, "contents": {"value": "```lean\nIrreducible.{u_1} {M : Type u_1} [Monoid M] (p : M) : Prop\n```\n***\n`Irreducible p` states that `p` is non-unit and only factors into units.\n\nWe explicitly avoid stating that `p` is non-zero, this would require a semiring. Assuming only a\nmonoid allows us to reuse irreducible for associated elements.\n\n***\n*import Mathlib.Algebra.Prime.Defs*", "kind": "markdown"}}
{"character": "i", "row": 2, "column": 76, "range": {"start": {"line": 2, "character": 69}, "end": {"line": 2, "character": 80}}, "contents": {"value": "```lean\nIrreducible.{u_1} {M : Type u_1} [Monoid M] (p : M) : Prop\n```\n***\n`Irreducible p` states that `p` is non-unit and only factors into units.\n\nWe explicitly avoid stating that `p` is non-zero, this would require a semiring. Assuming only a\nmonoid allows us to reuse irreducible for associated elements.\n\n***\n*import Mathlib.Algebra.Prime.Defs*", "kind": "markdown"}}
{"character": "b", "row": 2, "column": 77, "range": {"start": {"line": 2, "character": 69}, "end": {"line": 2, "character": 80}}, "contents": {"value": "```lean\nIrreducible.{u_1} {M : Type u_1} [Monoid M] (p : M) : Prop\n```\n***\n`Irreducible p` states that `p` is non-unit and only factors into units.\n\nWe explicitly avoid stating that `p` is non-zero, this would require a semiring. Assuming only a\nmonoid allows us to reuse irreducible for associated elements.\n\n***\n*import Mathlib.Algebra.Prime.Defs*", "kind": "markdown"}}
{"character": "l", "row": 2, "column": 78, "range": {"start": {"line": 2, "character": 69}, "end": {"line": 2, "character": 80}}, "contents": {"value": "```lean\nIrreducible.{u_1} {M : Type u_1} [Monoid M] (p : M) : Prop\n```\n***\n`Irreducible p` states that `p` is non-unit and only factors into units.\n\nWe explicitly avoid stating that `p` is non-zero, this would require a semiring. Assuming only a\nmonoid allows us to reuse irreducible for associated elements.\n\n***\n*import Mathlib.Algebra.Prime.Defs*", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 79, "range": {"start": {"line": 2, "character": 69}, "end": {"line": 2, "character": 80}}, "contents": {"value": "```lean\nIrreducible.{u_1} {M : Type u_1} [Monoid M] (p : M) : Prop\n```\n***\n`Irreducible p` states that `p` is non-unit and only factors into units.\n\nWe explicitly avoid stating that `p` is non-zero, this would require a semiring. Assuming only a\nmonoid allows us to reuse irreducible for associated elements.\n\n***\n*import Mathlib.Algebra.Prime.Defs*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 80, "range": {"start": {"line": 2, "character": 69}, "end": {"line": 2, "character": 82}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "2", "row": 2, "column": 81, "range": {"start": {"line": 2, "character": 81}, "end": {"line": 2, "character": 82}}, "contents": {"value": "```lean\n2 : ℕ\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 82}
{"character": ":", "row": 2, "column": 83}
{"character": "=", "row": 2, "column": 84}
{"character": " ", "row": 2, "column": 85}
{"character": "b", "row": 2, "column": 86, "range": {"start": {"line": 2, "character": 86}, "end": {"line": 2, "character": 94}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 87, "range": {"start": {"line": 2, "character": 86}, "end": {"line": 2, "character": 94}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 88, "range": {"start": {"line": 2, "character": 86}, "end": {"line": 2, "character": 94}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": "s", "row": 2, "column": 89, "range": {"start": {"line": 2, "character": 89}, "end": {"line": 2, "character": 94}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 90, "range": {"start": {"line": 2, "character": 89}, "end": {"line": 2, "character": 94}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 91, "range": {"start": {"line": 2, "character": 89}, "end": {"line": 2, "character": 94}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 92, "range": {"start": {"line": 2, "character": 89}, "end": {"line": 2, "character": 94}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 93, "range": {"start": {"line": 2, "character": 89}, "end": {"line": 2, "character": 94}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
