{"character": "i", "row": 0, "column": 0}
{"character": "m", "row": 0, "column": 1}
{"character": "p", "row": 0, "column": 2}
{"character": "o", "row": 0, "column": 3}
{"character": "r", "row": 0, "column": 4}
{"character": "t", "row": 0, "column": 5}
{"character": " ", "row": 0, "column": 6}
{"character": "M", "row": 0, "column": 7}
{"character": "a", "row": 0, "column": 8}
{"character": "t", "row": 0, "column": 9}
{"character": "h", "row": 0, "column": 10}
{"character": "l", "row": 0, "column": 11}
{"character": "i", "row": 0, "column": 12}
{"character": "b", "row": 0, "column": 13}
{"character": "t", "row": 2, "column": 0}
{"character": "h", "row": 2, "column": 1}
{"character": "e", "row": 2, "column": 2}
{"character": "o", "row": 2, "column": 3}
{"character": "r", "row": 2, "column": 4}
{"character": "e", "row": 2, "column": 5}
{"character": "m", "row": 2, "column": 6}
{"character": " ", "row": 2, "column": 7}
{"character": "i", "row": 2, "column": 8, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "m", "row": 2, "column": 9, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "a", "row": 2, "column": 10, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "g", "row": 2, "column": 11, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 12, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 13, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 14, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 15, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 16, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "m", "row": 2, "column": 17, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "a", "row": 2, "column": 18, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "l", "row": 2, "column": 19, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 20, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 21, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "x", "row": 2, "column": 22, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 23, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 24, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "a", "row": 2, "column": 25, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "c", "row": 2, "column": 26, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 27, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 28, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": "d", "row": 2, "column": 29, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 30}}, "contents": {"value": "```lean\nimage_normal_extracted.{u_1, u_2} {G : Type u_1} {G' : Type u_2} [Group G] [Group G'] {φ : G →* G'} :\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```", "kind": "markdown"}}
{"character": ".", "row": 2, "column": 30, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 41}}, "contents": {"value": "```lean\nimage_normal_extracted : ∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {φ : G →* G'},\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "{", "row": 2, "column": 31, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 41}}, "contents": {"value": "```lean\nimage_normal_extracted : ∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {φ : G →* G'},\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 32, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 41}}, "contents": {"value": "```lean\nimage_normal_extracted : ∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {φ : G →* G'},\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 33, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 41}}, "contents": {"value": "```lean\nimage_normal_extracted : ∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {φ : G →* G'},\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "1", "row": 2, "column": 34, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 41}}, "contents": {"value": "```lean\nimage_normal_extracted : ∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {φ : G →* G'},\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": ",", "row": 2, "column": 35, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 41}}, "contents": {"value": "```lean\nimage_normal_extracted : ∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {φ : G →* G'},\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 36, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 41}}, "contents": {"value": "```lean\nimage_normal_extracted : ∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {φ : G →* G'},\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 37, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 41}}, "contents": {"value": "```lean\nimage_normal_extracted : ∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {φ : G →* G'},\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 38, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 41}}, "contents": {"value": "```lean\nimage_normal_extracted : ∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {φ : G →* G'},\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "2", "row": 2, "column": 39, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 41}}, "contents": {"value": "```lean\nimage_normal_extracted : ∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {φ : G →* G'},\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "}", "row": 2, "column": 40, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 41}}, "contents": {"value": "```lean\nimage_normal_extracted : ∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {φ : G →* G'},\n  Function.Surjective ⇑φ → ∀ {N : Subgroup G}, N.Normal → (Subgroup.map φ N).Normal\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 41}
{"character": "{", "row": 2, "column": 42, "range": {"start": {"line": 2, "character": 42}, "end": {"line": 2, "character": 56}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": "G", "row": 2, "column": 43, "range": {"start": {"line": 2, "character": 43}, "end": {"line": 2, "character": 44}}, "contents": {"value": "```lean\nG : Type u_1\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 44}
{"character": ":", "row": 2, "column": 45, "range": {"start": {"line": 2, "character": 42}, "end": {"line": 2, "character": 56}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 46}
{"character": "T", "row": 2, "column": 47, "range": {"start": {"line": 2, "character": 47}, "end": {"line": 2, "character": 55}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 48, "range": {"start": {"line": 2, "character": 47}, "end": {"line": 2, "character": 55}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 49, "range": {"start": {"line": 2, "character": 47}, "end": {"line": 2, "character": 55}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 50, "range": {"start": {"line": 2, "character": 47}, "end": {"line": 2, "character": 55}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 51, "range": {"start": {"line": 2, "character": 47}, "end": {"line": 2, "character": 55}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 52, "range": {"start": {"line": 2, "character": 47}, "end": {"line": 2, "character": 55}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 53, "range": {"start": {"line": 2, "character": 47}, "end": {"line": 2, "character": 55}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "1", "row": 2, "column": 54, "range": {"start": {"line": 2, "character": 47}, "end": {"line": 2, "character": 55}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "}", "row": 2, "column": 55, "range": {"start": {"line": 2, "character": 42}, "end": {"line": 2, "character": 56}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 56}
{"character": "{", "row": 2, "column": 57, "range": {"start": {"line": 2, "character": 57}, "end": {"line": 2, "character": 72}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": "G", "row": 2, "column": 58, "range": {"start": {"line": 2, "character": 58}, "end": {"line": 2, "character": 60}}, "contents": {"value": "```lean\nG' : Type u_2\n```", "kind": "markdown"}}
{"character": "'", "row": 2, "column": 59, "range": {"start": {"line": 2, "character": 58}, "end": {"line": 2, "character": 60}}, "contents": {"value": "```lean\nG' : Type u_2\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 60}
{"character": ":", "row": 2, "column": 61, "range": {"start": {"line": 2, "character": 57}, "end": {"line": 2, "character": 72}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 62}
{"character": "T", "row": 2, "column": 63, "range": {"start": {"line": 2, "character": 63}, "end": {"line": 2, "character": 71}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 64, "range": {"start": {"line": 2, "character": 63}, "end": {"line": 2, "character": 71}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 65, "range": {"start": {"line": 2, "character": 63}, "end": {"line": 2, "character": 71}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 66, "range": {"start": {"line": 2, "character": 63}, "end": {"line": 2, "character": 71}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 67, "range": {"start": {"line": 2, "character": 63}, "end": {"line": 2, "character": 71}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 68, "range": {"start": {"line": 2, "character": 63}, "end": {"line": 2, "character": 71}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 69, "range": {"start": {"line": 2, "character": 63}, "end": {"line": 2, "character": 71}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "2", "row": 2, "column": 70, "range": {"start": {"line": 2, "character": 63}, "end": {"line": 2, "character": 71}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "}", "row": 2, "column": 71, "range": {"start": {"line": 2, "character": 57}, "end": {"line": 2, "character": 72}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 72}
{"character": "[", "row": 2, "column": 73, "range": {"start": {"line": 2, "character": 73}, "end": {"line": 2, "character": 82}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "G", "row": 2, "column": 74, "range": {"start": {"line": 2, "character": 74}, "end": {"line": 2, "character": 79}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 75, "range": {"start": {"line": 2, "character": 74}, "end": {"line": 2, "character": 79}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 76, "range": {"start": {"line": 2, "character": 74}, "end": {"line": 2, "character": 79}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 77, "range": {"start": {"line": 2, "character": 74}, "end": {"line": 2, "character": 79}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 78, "range": {"start": {"line": 2, "character": 74}, "end": {"line": 2, "character": 79}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 79, "range": {"start": {"line": 2, "character": 74}, "end": {"line": 2, "character": 81}}, "contents": {"value": "```lean\nType u_1\n```", "kind": "markdown"}}
{"character": "G", "row": 2, "column": 80, "range": {"start": {"line": 2, "character": 80}, "end": {"line": 2, "character": 81}}, "contents": {"value": "```lean\nG : Type u_1\n```", "kind": "markdown"}}
{"character": "]", "row": 2, "column": 81, "range": {"start": {"line": 2, "character": 73}, "end": {"line": 2, "character": 82}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 82}
{"character": "[", "row": 2, "column": 83, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 93}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "G", "row": 2, "column": 84, "range": {"start": {"line": 2, "character": 84}, "end": {"line": 2, "character": 89}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 85, "range": {"start": {"line": 2, "character": 84}, "end": {"line": 2, "character": 89}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 86, "range": {"start": {"line": 2, "character": 84}, "end": {"line": 2, "character": 89}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 87, "range": {"start": {"line": 2, "character": 84}, "end": {"line": 2, "character": 89}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 88, "range": {"start": {"line": 2, "character": 84}, "end": {"line": 2, "character": 89}}, "contents": {"value": "```lean\nGroup.{u} (G : Type u) : Type u\n```\n***\nA `Group` is a `Monoid` with an operation `⁻¹` satisfying `a⁻¹ * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b⁻¹`,\nwith a default so that `a / b = a * b⁻¹` holds by definition.\n\nUse `Group.ofLeftAxioms` or `Group.ofRightAxioms` to define a group structure\non a type with the minimum proof obligations.\n\n***\n*import Mathlib.Algebra.Group.Defs*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 89, "range": {"start": {"line": 2, "character": 84}, "end": {"line": 2, "character": 92}}, "contents": {"value": "```lean\nType u_2\n```", "kind": "markdown"}}
{"character": "G", "row": 2, "column": 90, "range": {"start": {"line": 2, "character": 90}, "end": {"line": 2, "character": 92}}, "contents": {"value": "```lean\nG' : Type u_2\n```", "kind": "markdown"}}
{"character": "'", "row": 2, "column": 91, "range": {"start": {"line": 2, "character": 90}, "end": {"line": 2, "character": 92}}, "contents": {"value": "```lean\nG' : Type u_2\n```", "kind": "markdown"}}
{"character": "]", "row": 2, "column": 92, "range": {"start": {"line": 2, "character": 83}, "end": {"line": 2, "character": 93}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 93}
{"character": "{", "row": 2, "column": 94, "range": {"start": {"line": 2, "character": 94}, "end": {"line": 2, "character": 107}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": "φ", "row": 2, "column": 95, "range": {"start": {"line": 2, "character": 95}, "end": {"line": 2, "character": 96}}, "contents": {"value": "```lean\nφ : G →* G'\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 96}
{"character": ":", "row": 2, "column": 97, "range": {"start": {"line": 2, "character": 94}, "end": {"line": 2, "character": 107}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 98}
{"character": "G", "row": 2, "column": 99, "range": {"start": {"line": 2, "character": 99}, "end": {"line": 2, "character": 100}}, "contents": {"value": "```lean\nG : Type u_1\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 100, "range": {"start": {"line": 2, "character": 99}, "end": {"line": 2, "character": 106}}, "contents": {"value": "```lean\nType (max u_1 u_2)\n```\n***\n`M →* N` denotes the type of monoid homomorphisms from `M` to `N`. ", "kind": "markdown"}}
{"character": "→", "row": 2, "column": 101, "range": {"start": {"line": 2, "character": 99}, "end": {"line": 2, "character": 106}}, "contents": {"value": "```lean\nType (max u_1 u_2)\n```\n***\n`M →* N` denotes the type of monoid homomorphisms from `M` to `N`. ", "kind": "markdown"}}
{"character": "*", "row": 2, "column": 102, "range": {"start": {"line": 2, "character": 99}, "end": {"line": 2, "character": 106}}, "contents": {"value": "```lean\nType (max u_1 u_2)\n```\n***\n`M →* N` denotes the type of monoid homomorphisms from `M` to `N`. ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 103, "range": {"start": {"line": 2, "character": 99}, "end": {"line": 2, "character": 106}}, "contents": {"value": "```lean\nType (max u_1 u_2)\n```\n***\n`M →* N` denotes the type of monoid homomorphisms from `M` to `N`. ", "kind": "markdown"}}
{"character": "G", "row": 2, "column": 104, "range": {"start": {"line": 2, "character": 104}, "end": {"line": 2, "character": 106}}, "contents": {"value": "```lean\nG' : Type u_2\n```", "kind": "markdown"}}
{"character": "'", "row": 2, "column": 105, "range": {"start": {"line": 2, "character": 104}, "end": {"line": 2, "character": 106}}, "contents": {"value": "```lean\nG' : Type u_2\n```", "kind": "markdown"}}
{"character": "}", "row": 2, "column": 106, "range": {"start": {"line": 2, "character": 94}, "end": {"line": 2, "character": 107}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 107}
{"character": ":", "row": 2, "column": 108, "range": {"start": {"line": 2, "character": 42}, "end": {"line": 2, "character": 191}}, "contents": {"value": "`declSig` matches the signature of a declaration with required type: a list of binders and then `: type` ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 109}
{"character": "F", "row": 2, "column": 110, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 111, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 112, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": "c", "row": 2, "column": 113, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 114, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": "i", "row": 2, "column": 115, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 116, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 117, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": ".", "row": 2, "column": 118, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": "S", "row": 2, "column": 119, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 120, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 121, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": "j", "row": 2, "column": 122, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 123, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": "c", "row": 2, "column": 124, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 125, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": "i", "row": 2, "column": 126, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": "v", "row": 2, "column": 127, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 128, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 129}}, "contents": {"value": "```lean\nFunction.Surjective.{u₁, u₂} {α : Sort u₁} {β : Sort u₂} (f : α → β) : Prop\n```\n***\nA function `f : α → β` is called surjective if every `b : β` is equal to `f a`\nfor some `a : α`. \n***\n*import Mathlib.Logic.Function.Defs*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 129, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 132}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "⇑", "row": 2, "column": 130, "range": {"start": {"line": 2, "character": 130}, "end": {"line": 2, "character": 132}}, "contents": {"value": "```lean\nG → G'\n```\n***\n`⇑ t` coerces `t` to a function. ", "kind": "markdown"}}
{"character": "φ", "row": 2, "column": 131, "range": {"start": {"line": 2, "character": 131}, "end": {"line": 2, "character": 132}}, "contents": {"value": "```lean\nφ : G →* G'\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 132, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "→", "row": 2, "column": 133, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 134, "range": {"start": {"line": 2, "character": 110}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "∀", "row": 2, "column": 135, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 136, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "{", "row": 2, "column": 137, "range": {"start": {"line": 2, "character": 137}, "end": {"line": 2, "character": 153}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": "N", "row": 2, "column": 138, "range": {"start": {"line": 2, "character": 138}, "end": {"line": 2, "character": 139}}, "contents": {"value": "```lean\nN : Subgroup G\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 139, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": ":", "row": 2, "column": 140, "range": {"start": {"line": 2, "character": 137}, "end": {"line": 2, "character": 153}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 141, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "S", "row": 2, "column": 142, "range": {"start": {"line": 2, "character": 142}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.{u_3} (G : Type u_3) [Group G] : Type u_3\n```\n***\nA subgroup of a group `G` is a subset containing 1, closed under multiplication\nand closed under multiplicative inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 143, "range": {"start": {"line": 2, "character": 142}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.{u_3} (G : Type u_3) [Group G] : Type u_3\n```\n***\nA subgroup of a group `G` is a subset containing 1, closed under multiplication\nand closed under multiplicative inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "b", "row": 2, "column": 144, "range": {"start": {"line": 2, "character": 142}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.{u_3} (G : Type u_3) [Group G] : Type u_3\n```\n***\nA subgroup of a group `G` is a subset containing 1, closed under multiplication\nand closed under multiplicative inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "g", "row": 2, "column": 145, "range": {"start": {"line": 2, "character": 142}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.{u_3} (G : Type u_3) [Group G] : Type u_3\n```\n***\nA subgroup of a group `G` is a subset containing 1, closed under multiplication\nand closed under multiplicative inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 146, "range": {"start": {"line": 2, "character": 142}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.{u_3} (G : Type u_3) [Group G] : Type u_3\n```\n***\nA subgroup of a group `G` is a subset containing 1, closed under multiplication\nand closed under multiplicative inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 147, "range": {"start": {"line": 2, "character": 142}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.{u_3} (G : Type u_3) [Group G] : Type u_3\n```\n***\nA subgroup of a group `G` is a subset containing 1, closed under multiplication\nand closed under multiplicative inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 148, "range": {"start": {"line": 2, "character": 142}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.{u_3} (G : Type u_3) [Group G] : Type u_3\n```\n***\nA subgroup of a group `G` is a subset containing 1, closed under multiplication\nand closed under multiplicative inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 149, "range": {"start": {"line": 2, "character": 142}, "end": {"line": 2, "character": 150}}, "contents": {"value": "```lean\nSubgroup.{u_3} (G : Type u_3) [Group G] : Type u_3\n```\n***\nA subgroup of a group `G` is a subset containing 1, closed under multiplication\nand closed under multiplicative inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 150, "range": {"start": {"line": 2, "character": 142}, "end": {"line": 2, "character": 152}}, "contents": {"value": "```lean\nType u_1\n```", "kind": "markdown"}}
{"character": "G", "row": 2, "column": 151, "range": {"start": {"line": 2, "character": 151}, "end": {"line": 2, "character": 152}}, "contents": {"value": "```lean\nG : Type u_1\n```", "kind": "markdown"}}
{"character": "}", "row": 2, "column": 152, "range": {"start": {"line": 2, "character": 137}, "end": {"line": 2, "character": 153}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": ",", "row": 2, "column": 153, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 154, "range": {"start": {"line": 2, "character": 135}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "N", "row": 2, "column": 155, "range": {"start": {"line": 2, "character": 155}, "end": {"line": 2, "character": 156}}, "contents": {"value": "```lean\nN : Subgroup G\n```", "kind": "markdown"}}
{"character": ".", "row": 2, "column": 156, "range": {"start": {"line": 2, "character": 155}, "end": {"line": 2, "character": 163}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "N", "row": 2, "column": 157, "range": {"start": {"line": 2, "character": 157}, "end": {"line": 2, "character": 163}}, "contents": {"value": "```lean\nSubgroup.Normal.{u_1} {G : Type u_1} [Group G] (H : Subgroup G) : Prop\n```\n***\nA subgroup is normal if whenever `n ∈ H`, then `g * n * g⁻¹ ∈ H` for every `g : G` \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 158, "range": {"start": {"line": 2, "character": 157}, "end": {"line": 2, "character": 163}}, "contents": {"value": "```lean\nSubgroup.Normal.{u_1} {G : Type u_1} [Group G] (H : Subgroup G) : Prop\n```\n***\nA subgroup is normal if whenever `n ∈ H`, then `g * n * g⁻¹ ∈ H` for every `g : G` \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 159, "range": {"start": {"line": 2, "character": 157}, "end": {"line": 2, "character": 163}}, "contents": {"value": "```lean\nSubgroup.Normal.{u_1} {G : Type u_1} [Group G] (H : Subgroup G) : Prop\n```\n***\nA subgroup is normal if whenever `n ∈ H`, then `g * n * g⁻¹ ∈ H` for every `g : G` \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "m", "row": 2, "column": 160, "range": {"start": {"line": 2, "character": 157}, "end": {"line": 2, "character": 163}}, "contents": {"value": "```lean\nSubgroup.Normal.{u_1} {G : Type u_1} [Group G] (H : Subgroup G) : Prop\n```\n***\nA subgroup is normal if whenever `n ∈ H`, then `g * n * g⁻¹ ∈ H` for every `g : G` \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "a", "row": 2, "column": 161, "range": {"start": {"line": 2, "character": 157}, "end": {"line": 2, "character": 163}}, "contents": {"value": "```lean\nSubgroup.Normal.{u_1} {G : Type u_1} [Group G] (H : Subgroup G) : Prop\n```\n***\nA subgroup is normal if whenever `n ∈ H`, then `g * n * g⁻¹ ∈ H` for every `g : G` \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "l", "row": 2, "column": 162, "range": {"start": {"line": 2, "character": 157}, "end": {"line": 2, "character": 163}}, "contents": {"value": "```lean\nSubgroup.Normal.{u_1} {G : Type u_1} [Group G] (H : Subgroup G) : Prop\n```\n***\nA subgroup is normal if whenever `n ∈ H`, then `g * n * g⁻¹ ∈ H` for every `g : G` \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 163, "range": {"start": {"line": 2, "character": 155}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "→", "row": 2, "column": 164, "range": {"start": {"line": 2, "character": 155}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 165, "range": {"start": {"line": 2, "character": 155}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "(", "row": 2, "column": 166, "range": {"start": {"line": 2, "character": 166}, "end": {"line": 2, "character": 184}}, "contents": {"value": "```lean\nSubgroup G'\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "S", "row": 2, "column": 167, "range": {"start": {"line": 2, "character": 167}, "end": {"line": 2, "character": 179}}, "contents": {"value": "```lean\nSubgroup.map.{u_1, u_5} {G : Type u_1} [Group G] {N : Type u_5} [Group N] (f : G →* N) (H : Subgroup G) : Subgroup N\n```\n***\nThe image of a subgroup along a monoid homomorphism is a subgroup. \n***\n*import Mathlib.Algebra.Group.Subgroup.Map*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 168, "range": {"start": {"line": 2, "character": 167}, "end": {"line": 2, "character": 179}}, "contents": {"value": "```lean\nSubgroup.map.{u_1, u_5} {G : Type u_1} [Group G] {N : Type u_5} [Group N] (f : G →* N) (H : Subgroup G) : Subgroup N\n```\n***\nThe image of a subgroup along a monoid homomorphism is a subgroup. \n***\n*import Mathlib.Algebra.Group.Subgroup.Map*", "kind": "markdown"}}
{"character": "b", "row": 2, "column": 169, "range": {"start": {"line": 2, "character": 167}, "end": {"line": 2, "character": 179}}, "contents": {"value": "```lean\nSubgroup.map.{u_1, u_5} {G : Type u_1} [Group G] {N : Type u_5} [Group N] (f : G →* N) (H : Subgroup G) : Subgroup N\n```\n***\nThe image of a subgroup along a monoid homomorphism is a subgroup. \n***\n*import Mathlib.Algebra.Group.Subgroup.Map*", "kind": "markdown"}}
{"character": "g", "row": 2, "column": 170, "range": {"start": {"line": 2, "character": 167}, "end": {"line": 2, "character": 179}}, "contents": {"value": "```lean\nSubgroup.map.{u_1, u_5} {G : Type u_1} [Group G] {N : Type u_5} [Group N] (f : G →* N) (H : Subgroup G) : Subgroup N\n```\n***\nThe image of a subgroup along a monoid homomorphism is a subgroup. \n***\n*import Mathlib.Algebra.Group.Subgroup.Map*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 171, "range": {"start": {"line": 2, "character": 167}, "end": {"line": 2, "character": 179}}, "contents": {"value": "```lean\nSubgroup.map.{u_1, u_5} {G : Type u_1} [Group G] {N : Type u_5} [Group N] (f : G →* N) (H : Subgroup G) : Subgroup N\n```\n***\nThe image of a subgroup along a monoid homomorphism is a subgroup. \n***\n*import Mathlib.Algebra.Group.Subgroup.Map*", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 172, "range": {"start": {"line": 2, "character": 167}, "end": {"line": 2, "character": 179}}, "contents": {"value": "```lean\nSubgroup.map.{u_1, u_5} {G : Type u_1} [Group G] {N : Type u_5} [Group N] (f : G →* N) (H : Subgroup G) : Subgroup N\n```\n***\nThe image of a subgroup along a monoid homomorphism is a subgroup. \n***\n*import Mathlib.Algebra.Group.Subgroup.Map*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 173, "range": {"start": {"line": 2, "character": 167}, "end": {"line": 2, "character": 179}}, "contents": {"value": "```lean\nSubgroup.map.{u_1, u_5} {G : Type u_1} [Group G] {N : Type u_5} [Group N] (f : G →* N) (H : Subgroup G) : Subgroup N\n```\n***\nThe image of a subgroup along a monoid homomorphism is a subgroup. \n***\n*import Mathlib.Algebra.Group.Subgroup.Map*", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 174, "range": {"start": {"line": 2, "character": 167}, "end": {"line": 2, "character": 179}}, "contents": {"value": "```lean\nSubgroup.map.{u_1, u_5} {G : Type u_1} [Group G] {N : Type u_5} [Group N] (f : G →* N) (H : Subgroup G) : Subgroup N\n```\n***\nThe image of a subgroup along a monoid homomorphism is a subgroup. \n***\n*import Mathlib.Algebra.Group.Subgroup.Map*", "kind": "markdown"}}
{"character": ".", "row": 2, "column": 175, "range": {"start": {"line": 2, "character": 167}, "end": {"line": 2, "character": 179}}, "contents": {"value": "```lean\nSubgroup.map.{u_1, u_5} {G : Type u_1} [Group G] {N : Type u_5} [Group N] (f : G →* N) (H : Subgroup G) : Subgroup N\n```\n***\nThe image of a subgroup along a monoid homomorphism is a subgroup. \n***\n*import Mathlib.Algebra.Group.Subgroup.Map*", "kind": "markdown"}}
{"character": "m", "row": 2, "column": 176, "range": {"start": {"line": 2, "character": 167}, "end": {"line": 2, "character": 179}}, "contents": {"value": "```lean\nSubgroup.map.{u_1, u_5} {G : Type u_1} [Group G] {N : Type u_5} [Group N] (f : G →* N) (H : Subgroup G) : Subgroup N\n```\n***\nThe image of a subgroup along a monoid homomorphism is a subgroup. \n***\n*import Mathlib.Algebra.Group.Subgroup.Map*", "kind": "markdown"}}
{"character": "a", "row": 2, "column": 177, "range": {"start": {"line": 2, "character": 167}, "end": {"line": 2, "character": 179}}, "contents": {"value": "```lean\nSubgroup.map.{u_1, u_5} {G : Type u_1} [Group G] {N : Type u_5} [Group N] (f : G →* N) (H : Subgroup G) : Subgroup N\n```\n***\nThe image of a subgroup along a monoid homomorphism is a subgroup. \n***\n*import Mathlib.Algebra.Group.Subgroup.Map*", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 178, "range": {"start": {"line": 2, "character": 167}, "end": {"line": 2, "character": 179}}, "contents": {"value": "```lean\nSubgroup.map.{u_1, u_5} {G : Type u_1} [Group G] {N : Type u_5} [Group N] (f : G →* N) (H : Subgroup G) : Subgroup N\n```\n***\nThe image of a subgroup along a monoid homomorphism is a subgroup. \n***\n*import Mathlib.Algebra.Group.Subgroup.Map*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 179, "range": {"start": {"line": 2, "character": 167}, "end": {"line": 2, "character": 183}}, "contents": {"value": "```lean\nSubgroup G'\n```", "kind": "markdown"}}
{"character": "φ", "row": 2, "column": 180, "range": {"start": {"line": 2, "character": 180}, "end": {"line": 2, "character": 181}}, "contents": {"value": "```lean\nφ : G →* G'\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 181, "range": {"start": {"line": 2, "character": 167}, "end": {"line": 2, "character": 183}}, "contents": {"value": "```lean\nSubgroup G'\n```", "kind": "markdown"}}
{"character": "N", "row": 2, "column": 182, "range": {"start": {"line": 2, "character": 182}, "end": {"line": 2, "character": 183}}, "contents": {"value": "```lean\nN : Subgroup G\n```", "kind": "markdown"}}
{"character": ")", "row": 2, "column": 183, "range": {"start": {"line": 2, "character": 166}, "end": {"line": 2, "character": 184}}, "contents": {"value": "```lean\nSubgroup G'\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": ".", "row": 2, "column": 184, "range": {"start": {"line": 2, "character": 166}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nProp\n```\n***\nThe *extended field notation* `e.f` is roughly short for `T.f e` where `T` is the type of `e`.\nMore precisely,\n* if `e` is of a function type, `e.f` is translated to `Function.f (p := e)`\n  where `p` is the first explicit parameter of function type\n* if `e` is of a named type `T ...` and there is a declaration `T.f` (possibly from `export`),\n  `e.f` is translated to `T.f (p := e)` where `p` is the first explicit parameter of type `T ...`\n* otherwise, if `e` is of a structure type,\n  the above is repeated for every base type of the structure.\n\nThe field index notation `e.i`, where `i` is a positive number,\nis short for accessing the `i`-th field (1-indexed) of `e` if it is of a structure type. ", "kind": "markdown"}}
{"character": "N", "row": 2, "column": 185, "range": {"start": {"line": 2, "character": 185}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nSubgroup.Normal.{u_1} {G : Type u_1} [Group G] (H : Subgroup G) : Prop\n```\n***\nA subgroup is normal if whenever `n ∈ H`, then `g * n * g⁻¹ ∈ H` for every `g : G` \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 186, "range": {"start": {"line": 2, "character": 185}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nSubgroup.Normal.{u_1} {G : Type u_1} [Group G] (H : Subgroup G) : Prop\n```\n***\nA subgroup is normal if whenever `n ∈ H`, then `g * n * g⁻¹ ∈ H` for every `g : G` \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 187, "range": {"start": {"line": 2, "character": 185}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nSubgroup.Normal.{u_1} {G : Type u_1} [Group G] (H : Subgroup G) : Prop\n```\n***\nA subgroup is normal if whenever `n ∈ H`, then `g * n * g⁻¹ ∈ H` for every `g : G` \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "m", "row": 2, "column": 188, "range": {"start": {"line": 2, "character": 185}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nSubgroup.Normal.{u_1} {G : Type u_1} [Group G] (H : Subgroup G) : Prop\n```\n***\nA subgroup is normal if whenever `n ∈ H`, then `g * n * g⁻¹ ∈ H` for every `g : G` \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "a", "row": 2, "column": 189, "range": {"start": {"line": 2, "character": 185}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nSubgroup.Normal.{u_1} {G : Type u_1} [Group G] (H : Subgroup G) : Prop\n```\n***\nA subgroup is normal if whenever `n ∈ H`, then `g * n * g⁻¹ ∈ H` for every `g : G` \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "l", "row": 2, "column": 190, "range": {"start": {"line": 2, "character": 185}, "end": {"line": 2, "character": 191}}, "contents": {"value": "```lean\nSubgroup.Normal.{u_1} {G : Type u_1} [Group G] (H : Subgroup G) : Prop\n```\n***\nA subgroup is normal if whenever `n ∈ H`, then `g * n * g⁻¹ ∈ H` for every `g : G` \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 191}
{"character": ":", "row": 2, "column": 192}
{"character": "=", "row": 2, "column": 193}
{"character": " ", "row": 2, "column": 194}
{"character": "b", "row": 2, "column": 195, "range": {"start": {"line": 2, "character": 195}, "end": {"line": 2, "character": 203}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 196, "range": {"start": {"line": 2, "character": 195}, "end": {"line": 2, "character": 203}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 197, "range": {"start": {"line": 2, "character": 195}, "end": {"line": 2, "character": 203}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": "s", "row": 2, "column": 198, "range": {"start": {"line": 2, "character": 198}, "end": {"line": 2, "character": 203}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 199, "range": {"start": {"line": 2, "character": 198}, "end": {"line": 2, "character": 203}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 200, "range": {"start": {"line": 2, "character": 198}, "end": {"line": 2, "character": 203}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 201, "range": {"start": {"line": 2, "character": 198}, "end": {"line": 2, "character": 203}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 202, "range": {"start": {"line": 2, "character": 198}, "end": {"line": 2, "character": 203}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
