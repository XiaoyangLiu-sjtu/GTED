{"character": "t", "row": 0, "column": 0}
{"character": "h", "row": 0, "column": 1}
{"character": "e", "row": 0, "column": 2}
{"character": "o", "row": 0, "column": 3}
{"character": "r", "row": 0, "column": 4}
{"character": "e", "row": 0, "column": 5}
{"character": "m", "row": 0, "column": 6}
{"character": " ", "row": 0, "column": 7}
{"character": "t", "row": 0, "column": 8}
{"character": "m", "row": 0, "column": 9}
{"character": "_", "row": 0, "column": 10}
{"character": "n", "row": 0, "column": 11}
{"character": "a", "row": 0, "column": 12}
{"character": "m", "row": 0, "column": 13}
{"character": "e", "row": 0, "column": 14}
{"character": " ", "row": 0, "column": 15}
{"character": "{", "row": 0, "column": 16, "range": {"start": {"line": 0, "character": 16}, "end": {"line": 0, "character": 27}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": "f", "row": 0, "column": 17, "range": {"start": {"line": 0, "character": 17}, "end": {"line": 0, "character": 18}}, "contents": {"value": "```lean\nf : ℝ → ℝ\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 18}
{"character": ":", "row": 0, "column": 19, "range": {"start": {"line": 0, "character": 16}, "end": {"line": 0, "character": 27}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 20}
{"character": "ℝ", "row": 0, "column": 21, "range": {"start": {"line": 0, "character": 21}, "end": {"line": 0, "character": 22}}, "contents": {"value": "```lean\nℝ : Type ?u.118\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 22, "range": {"start": {"line": 0, "character": 21}, "end": {"line": 0, "character": 26}}, "contents": {"value": "```lean\nType ?u.118\n```", "kind": "markdown"}}
{"character": "→", "row": 0, "column": 23, "range": {"start": {"line": 0, "character": 21}, "end": {"line": 0, "character": 26}}, "contents": {"value": "```lean\nType ?u.118\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 24, "range": {"start": {"line": 0, "character": 21}, "end": {"line": 0, "character": 26}}, "contents": {"value": "```lean\nType ?u.118\n```", "kind": "markdown"}}
{"character": "ℝ", "row": 0, "column": 25, "range": {"start": {"line": 0, "character": 25}, "end": {"line": 0, "character": 26}}, "contents": {"value": "```lean\nℝ : Type ?u.118\n```", "kind": "markdown"}}
{"character": "}", "row": 0, "column": 26, "range": {"start": {"line": 0, "character": 16}, "end": {"line": 0, "character": 27}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 27}
{"character": "{", "row": 0, "column": 28, "range": {"start": {"line": 0, "character": 28}, "end": {"line": 0, "character": 37}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": "a", "row": 0, "column": 29, "range": {"start": {"line": 0, "character": 29}, "end": {"line": 0, "character": 30}}, "contents": {"value": "```lean\na : ℝ\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 30}
{"character": "b", "row": 0, "column": 31, "range": {"start": {"line": 0, "character": 31}, "end": {"line": 0, "character": 32}}, "contents": {"value": "```lean\nb : ℝ\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 32}
{"character": ":", "row": 0, "column": 33, "range": {"start": {"line": 0, "character": 28}, "end": {"line": 0, "character": 37}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 34}
{"character": "ℝ", "row": 0, "column": 35, "range": {"start": {"line": 0, "character": 35}, "end": {"line": 0, "character": 36}}, "contents": {"value": "```lean\nℝ : Type ?u.118\n```", "kind": "markdown"}}
{"character": "}", "row": 0, "column": 36, "range": {"start": {"line": 0, "character": 28}, "end": {"line": 0, "character": 37}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 37}
{"character": ":", "row": 0, "column": 38}
{"character": " ", "row": 0, "column": 39}
{"character": "U", "row": 0, "column": 40, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "n", "row": 0, "column": 41, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "i", "row": 0, "column": 42, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "f", "row": 0, "column": 43, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "o", "row": 0, "column": 44, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "r", "row": 0, "column": 45, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "m", "row": 0, "column": 46, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "C", "row": 0, "column": 47, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "o", "row": 0, "column": 48, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "n", "row": 0, "column": 49, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "t", "row": 0, "column": 50, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "i", "row": 0, "column": 51, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "n", "row": 0, "column": 52, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "u", "row": 0, "column": 53, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "o", "row": 0, "column": 54, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "u", "row": 0, "column": 55, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "s", "row": 0, "column": 56, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "O", "row": 0, "column": 57, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": "n", "row": 0, "column": 58, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 59}}, "contents": {"value": "```lean\nUniformContinuousOn : ?m.16\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 59}
{"character": "f", "row": 0, "column": 60, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 177}}, "contents": {"value": "If and only if, or logical bi-implication. `a ↔ b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `↔` in identifiers is `iff`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 61}
{"character": "(", "row": 0, "column": 62, "range": {"start": {"line": 0, "character": 62}, "end": {"line": 0, "character": 71}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "I", "row": 0, "column": 63, "range": {"start": {"line": 0, "character": 62}, "end": {"line": 0, "character": 71}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "c", "row": 0, "column": 64, "range": {"start": {"line": 0, "character": 62}, "end": {"line": 0, "character": 71}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "c", "row": 0, "column": 65, "range": {"start": {"line": 0, "character": 62}, "end": {"line": 0, "character": 71}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 66}
{"character": "a", "row": 0, "column": 67, "range": {"start": {"line": 0, "character": 62}, "end": {"line": 0, "character": 71}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 68}
{"character": "b", "row": 0, "column": 69, "range": {"start": {"line": 0, "character": 62}, "end": {"line": 0, "character": 71}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": ")", "row": 0, "column": 70, "range": {"start": {"line": 0, "character": 62}, "end": {"line": 0, "character": 71}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 71, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```\n***\nIf and only if, or logical bi-implication. `a ↔ b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `↔` in identifiers is `iff`.", "kind": "markdown"}}
{"character": "↔", "row": 0, "column": 72, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```\n***\nIf and only if, or logical bi-implication. `a ↔ b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `↔` in identifiers is `iff`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 73, "range": {"start": {"line": 0, "character": 40}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```\n***\nIf and only if, or logical bi-implication. `a ↔ b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `↔` in identifiers is `iff`.", "kind": "markdown"}}
{"character": "∃", "row": 0, "column": 74, "range": {"start": {"line": 0, "character": 74}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 75, "range": {"start": {"line": 0, "character": 74}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "μ", "row": 0, "column": 76, "range": {"start": {"line": 0, "character": 76}, "end": {"line": 0, "character": 77}}, "contents": {"value": "```lean\nμ : ?m.105\n```", "kind": "markdown"}}
{"character": ",", "row": 0, "column": 77, "range": {"start": {"line": 0, "character": 74}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 78, "range": {"start": {"line": 0, "character": 74}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "C", "row": 0, "column": 79, "range": {"start": {"line": 0, "character": 79}, "end": {"line": 0, "character": 91}}, "contents": {"value": "```lean\nContinuousOn : ?m.34\n```", "kind": "markdown"}}
{"character": "o", "row": 0, "column": 80, "range": {"start": {"line": 0, "character": 79}, "end": {"line": 0, "character": 91}}, "contents": {"value": "```lean\nContinuousOn : ?m.34\n```", "kind": "markdown"}}
{"character": "n", "row": 0, "column": 81, "range": {"start": {"line": 0, "character": 79}, "end": {"line": 0, "character": 91}}, "contents": {"value": "```lean\nContinuousOn : ?m.34\n```", "kind": "markdown"}}
{"character": "t", "row": 0, "column": 82, "range": {"start": {"line": 0, "character": 79}, "end": {"line": 0, "character": 91}}, "contents": {"value": "```lean\nContinuousOn : ?m.34\n```", "kind": "markdown"}}
{"character": "i", "row": 0, "column": 83, "range": {"start": {"line": 0, "character": 79}, "end": {"line": 0, "character": 91}}, "contents": {"value": "```lean\nContinuousOn : ?m.34\n```", "kind": "markdown"}}
{"character": "n", "row": 0, "column": 84, "range": {"start": {"line": 0, "character": 79}, "end": {"line": 0, "character": 91}}, "contents": {"value": "```lean\nContinuousOn : ?m.34\n```", "kind": "markdown"}}
{"character": "u", "row": 0, "column": 85, "range": {"start": {"line": 0, "character": 79}, "end": {"line": 0, "character": 91}}, "contents": {"value": "```lean\nContinuousOn : ?m.34\n```", "kind": "markdown"}}
{"character": "o", "row": 0, "column": 86, "range": {"start": {"line": 0, "character": 79}, "end": {"line": 0, "character": 91}}, "contents": {"value": "```lean\nContinuousOn : ?m.34\n```", "kind": "markdown"}}
{"character": "u", "row": 0, "column": 87, "range": {"start": {"line": 0, "character": 79}, "end": {"line": 0, "character": 91}}, "contents": {"value": "```lean\nContinuousOn : ?m.34\n```", "kind": "markdown"}}
{"character": "s", "row": 0, "column": 88, "range": {"start": {"line": 0, "character": 79}, "end": {"line": 0, "character": 91}}, "contents": {"value": "```lean\nContinuousOn : ?m.34\n```", "kind": "markdown"}}
{"character": "O", "row": 0, "column": 89, "range": {"start": {"line": 0, "character": 79}, "end": {"line": 0, "character": 91}}, "contents": {"value": "```lean\nContinuousOn : ?m.34\n```", "kind": "markdown"}}
{"character": "n", "row": 0, "column": 90, "range": {"start": {"line": 0, "character": 79}, "end": {"line": 0, "character": 91}}, "contents": {"value": "```lean\nContinuousOn : ?m.34\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 91}
{"character": "μ", "row": 0, "column": 92, "range": {"start": {"line": 0, "character": 79}, "end": {"line": 0, "character": 177}}, "contents": {"value": "`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 93}
{"character": "(", "row": 0, "column": 94, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 109}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "I", "row": 0, "column": 95, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 109}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "c", "row": 0, "column": 96, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 109}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "c", "row": 0, "column": 97, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 109}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 98}
{"character": "0", "row": 0, "column": 99, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 109}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 100}
{"character": "(", "row": 0, "column": 101, "range": {"start": {"line": 0, "character": 101}, "end": {"line": 0, "character": 108}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "b", "row": 0, "column": 102, "range": {"start": {"line": 0, "character": 102}, "end": {"line": 0, "character": 107}}, "contents": {"value": "`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a ≤ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `sub` (when used as a binary operator).", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 103}
{"character": "-", "row": 0, "column": 104, "range": {"start": {"line": 0, "character": 102}, "end": {"line": 0, "character": 107}}, "contents": {"value": "`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a ≤ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `sub` (when used as a binary operator).", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 105}
{"character": "a", "row": 0, "column": 106, "range": {"start": {"line": 0, "character": 102}, "end": {"line": 0, "character": 107}}, "contents": {"value": "`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a ≤ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `sub` (when used as a binary operator).", "kind": "markdown"}}
{"character": ")", "row": 0, "column": 107, "range": {"start": {"line": 0, "character": 101}, "end": {"line": 0, "character": 108}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": ")", "row": 0, "column": 108, "range": {"start": {"line": 0, "character": 94}, "end": {"line": 0, "character": 109}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 109, "range": {"start": {"line": 0, "character": 79}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```\n***\n`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.", "kind": "markdown"}}
{"character": "∧", "row": 0, "column": 110, "range": {"start": {"line": 0, "character": 79}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```\n***\n`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 111, "range": {"start": {"line": 0, "character": 79}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```\n***\n`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.", "kind": "markdown"}}
{"character": "S", "row": 0, "column": 112, "range": {"start": {"line": 0, "character": 112}, "end": {"line": 0, "character": 124}}, "contents": {"value": "```lean\nStrictMonoOn : ?m.53\n```", "kind": "markdown"}}
{"character": "t", "row": 0, "column": 113, "range": {"start": {"line": 0, "character": 112}, "end": {"line": 0, "character": 124}}, "contents": {"value": "```lean\nStrictMonoOn : ?m.53\n```", "kind": "markdown"}}
{"character": "r", "row": 0, "column": 114, "range": {"start": {"line": 0, "character": 112}, "end": {"line": 0, "character": 124}}, "contents": {"value": "```lean\nStrictMonoOn : ?m.53\n```", "kind": "markdown"}}
{"character": "i", "row": 0, "column": 115, "range": {"start": {"line": 0, "character": 112}, "end": {"line": 0, "character": 124}}, "contents": {"value": "```lean\nStrictMonoOn : ?m.53\n```", "kind": "markdown"}}
{"character": "c", "row": 0, "column": 116, "range": {"start": {"line": 0, "character": 112}, "end": {"line": 0, "character": 124}}, "contents": {"value": "```lean\nStrictMonoOn : ?m.53\n```", "kind": "markdown"}}
{"character": "t", "row": 0, "column": 117, "range": {"start": {"line": 0, "character": 112}, "end": {"line": 0, "character": 124}}, "contents": {"value": "```lean\nStrictMonoOn : ?m.53\n```", "kind": "markdown"}}
{"character": "M", "row": 0, "column": 118, "range": {"start": {"line": 0, "character": 112}, "end": {"line": 0, "character": 124}}, "contents": {"value": "```lean\nStrictMonoOn : ?m.53\n```", "kind": "markdown"}}
{"character": "o", "row": 0, "column": 119, "range": {"start": {"line": 0, "character": 112}, "end": {"line": 0, "character": 124}}, "contents": {"value": "```lean\nStrictMonoOn : ?m.53\n```", "kind": "markdown"}}
{"character": "n", "row": 0, "column": 120, "range": {"start": {"line": 0, "character": 112}, "end": {"line": 0, "character": 124}}, "contents": {"value": "```lean\nStrictMonoOn : ?m.53\n```", "kind": "markdown"}}
{"character": "o", "row": 0, "column": 121, "range": {"start": {"line": 0, "character": 112}, "end": {"line": 0, "character": 124}}, "contents": {"value": "```lean\nStrictMonoOn : ?m.53\n```", "kind": "markdown"}}
{"character": "O", "row": 0, "column": 122, "range": {"start": {"line": 0, "character": 112}, "end": {"line": 0, "character": 124}}, "contents": {"value": "```lean\nStrictMonoOn : ?m.53\n```", "kind": "markdown"}}
{"character": "n", "row": 0, "column": 123, "range": {"start": {"line": 0, "character": 112}, "end": {"line": 0, "character": 124}}, "contents": {"value": "```lean\nStrictMonoOn : ?m.53\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 124}
{"character": "μ", "row": 0, "column": 125, "range": {"start": {"line": 0, "character": 112}, "end": {"line": 0, "character": 177}}, "contents": {"value": "`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 126}
{"character": "(", "row": 0, "column": 127, "range": {"start": {"line": 0, "character": 127}, "end": {"line": 0, "character": 134}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "I", "row": 0, "column": 128, "range": {"start": {"line": 0, "character": 127}, "end": {"line": 0, "character": 134}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "o", "row": 0, "column": 129, "range": {"start": {"line": 0, "character": 127}, "end": {"line": 0, "character": 134}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "i", "row": 0, "column": 130, "range": {"start": {"line": 0, "character": 127}, "end": {"line": 0, "character": 134}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 131}
{"character": "0", "row": 0, "column": 132, "range": {"start": {"line": 0, "character": 127}, "end": {"line": 0, "character": 134}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": ")", "row": 0, "column": 133, "range": {"start": {"line": 0, "character": 127}, "end": {"line": 0, "character": 134}}, "contents": {"value": "Parentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 134, "range": {"start": {"line": 0, "character": 112}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```\n***\n`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.", "kind": "markdown"}}
{"character": "∧", "row": 0, "column": 135, "range": {"start": {"line": 0, "character": 112}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```\n***\n`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 136, "range": {"start": {"line": 0, "character": 112}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```\n***\n`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.", "kind": "markdown"}}
{"character": "∀", "row": 0, "column": 137, "range": {"start": {"line": 0, "character": 137}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 138, "range": {"start": {"line": 0, "character": 137}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "(", "row": 0, "column": 139, "range": {"start": {"line": 0, "character": 139}, "end": {"line": 0, "character": 148}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "s", "row": 0, "column": 140, "range": {"start": {"line": 0, "character": 140}, "end": {"line": 0, "character": 141}}, "contents": {"value": "```lean\ns : ℝ\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 141, "range": {"start": {"line": 0, "character": 137}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "t", "row": 0, "column": 142, "range": {"start": {"line": 0, "character": 142}, "end": {"line": 0, "character": 143}}, "contents": {"value": "```lean\nt : ℝ\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 143, "range": {"start": {"line": 0, "character": 137}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": ":", "row": 0, "column": 144, "range": {"start": {"line": 0, "character": 139}, "end": {"line": 0, "character": 148}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 145, "range": {"start": {"line": 0, "character": 137}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "ℝ", "row": 0, "column": 146, "range": {"start": {"line": 0, "character": 146}, "end": {"line": 0, "character": 147}}, "contents": {"value": "```lean\nℝ : Type ?u.118\n```", "kind": "markdown"}}
{"character": ")", "row": 0, "column": 147, "range": {"start": {"line": 0, "character": 139}, "end": {"line": 0, "character": 148}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": ",", "row": 0, "column": 148, "range": {"start": {"line": 0, "character": 137}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 149, "range": {"start": {"line": 0, "character": 137}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "s", "row": 0, "column": 150, "range": {"start": {"line": 0, "character": 150}, "end": {"line": 0, "character": 151}}, "contents": {"value": "```lean\ns : ℝ\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 151, "range": {"start": {"line": 0, "character": 150}, "end": {"line": 0, "character": 161}}, "contents": {"value": "```lean\nProp\n```\n***\nThe membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "∈", "row": 0, "column": 152, "range": {"start": {"line": 0, "character": 150}, "end": {"line": 0, "character": 161}}, "contents": {"value": "```lean\nProp\n```\n***\nThe membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 153, "range": {"start": {"line": 0, "character": 150}, "end": {"line": 0, "character": 161}}, "contents": {"value": "```lean\nProp\n```\n***\nThe membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "I", "row": 0, "column": 154, "range": {"start": {"line": 0, "character": 154}, "end": {"line": 0, "character": 157}}, "contents": {"value": "```lean\nIcc : ?m.92\n```", "kind": "markdown"}}
{"character": "c", "row": 0, "column": 155, "range": {"start": {"line": 0, "character": 154}, "end": {"line": 0, "character": 157}}, "contents": {"value": "```lean\nIcc : ?m.92\n```", "kind": "markdown"}}
{"character": "c", "row": 0, "column": 156, "range": {"start": {"line": 0, "character": 154}, "end": {"line": 0, "character": 157}}, "contents": {"value": "```lean\nIcc : ?m.92\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 157}
{"character": "a", "row": 0, "column": 158, "range": {"start": {"line": 0, "character": 150}, "end": {"line": 0, "character": 161}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 159}
{"character": "b", "row": 0, "column": 160, "range": {"start": {"line": 0, "character": 150}, "end": {"line": 0, "character": 161}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 161, "range": {"start": {"line": 0, "character": 150}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "→", "row": 0, "column": 162, "range": {"start": {"line": 0, "character": 150}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 163, "range": {"start": {"line": 0, "character": 150}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "t", "row": 0, "column": 164, "range": {"start": {"line": 0, "character": 164}, "end": {"line": 0, "character": 165}}, "contents": {"value": "```lean\nt : ℝ\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 165, "range": {"start": {"line": 0, "character": 164}, "end": {"line": 0, "character": 175}}, "contents": {"value": "```lean\nProp\n```\n***\nThe membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "∈", "row": 0, "column": 166, "range": {"start": {"line": 0, "character": 164}, "end": {"line": 0, "character": 175}}, "contents": {"value": "```lean\nProp\n```\n***\nThe membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 167, "range": {"start": {"line": 0, "character": 164}, "end": {"line": 0, "character": 175}}, "contents": {"value": "```lean\nProp\n```\n***\nThe membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "I", "row": 0, "column": 168, "range": {"start": {"line": 0, "character": 168}, "end": {"line": 0, "character": 171}}, "contents": {"value": "```lean\nIcc : ?m.92\n```", "kind": "markdown"}}
{"character": "c", "row": 0, "column": 169, "range": {"start": {"line": 0, "character": 168}, "end": {"line": 0, "character": 171}}, "contents": {"value": "```lean\nIcc : ?m.92\n```", "kind": "markdown"}}
{"character": "c", "row": 0, "column": 170, "range": {"start": {"line": 0, "character": 168}, "end": {"line": 0, "character": 171}}, "contents": {"value": "```lean\nIcc : ?m.92\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 171}
{"character": "a", "row": 0, "column": 172, "range": {"start": {"line": 0, "character": 164}, "end": {"line": 0, "character": 175}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 173}
{"character": "b", "row": 0, "column": 174, "range": {"start": {"line": 0, "character": 164}, "end": {"line": 0, "character": 175}}, "contents": {"value": "The membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 175, "range": {"start": {"line": 0, "character": 164}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "→", "row": 0, "column": 176, "range": {"start": {"line": 0, "character": 164}, "end": {"line": 0, "character": 177}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": " ", "row": 0, "column": 177}
{"character": "|", "row": 0, "column": 178}
{"character": "f", "row": 0, "column": 179}
{"character": " ", "row": 0, "column": 180}
{"character": "s", "row": 0, "column": 181}
{"character": " ", "row": 0, "column": 182}
{"character": "-", "row": 0, "column": 183}
{"character": " ", "row": 0, "column": 184}
{"character": "f", "row": 0, "column": 185}
{"character": " ", "row": 0, "column": 186}
{"character": "t", "row": 0, "column": 187}
{"character": "|", "row": 0, "column": 188}
{"character": " ", "row": 0, "column": 189}
{"character": "≤", "row": 0, "column": 190}
{"character": " ", "row": 0, "column": 191}
{"character": "μ", "row": 0, "column": 192}
{"character": " ", "row": 0, "column": 193}
{"character": "|", "row": 0, "column": 194}
{"character": "s", "row": 0, "column": 195}
{"character": " ", "row": 0, "column": 196}
{"character": "-", "row": 0, "column": 197}
{"character": " ", "row": 0, "column": 198}
{"character": "t", "row": 0, "column": 199}
{"character": "|", "row": 0, "column": 200}
{"character": " ", "row": 0, "column": 201}
{"character": ":", "row": 0, "column": 202}
{"character": "=", "row": 0, "column": 203}
{"character": " ", "row": 0, "column": 204}
{"character": "b", "row": 0, "column": 205}
{"character": "y", "row": 0, "column": 206}
{"character": " ", "row": 0, "column": 207}
{"character": "s", "row": 0, "column": 208}
{"character": "o", "row": 0, "column": 209}
{"character": "r", "row": 0, "column": 210}
{"character": "r", "row": 0, "column": 211}
{"character": "y", "row": 0, "column": 212}
