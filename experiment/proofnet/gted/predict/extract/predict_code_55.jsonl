{"character": "i", "row": 0, "column": 0}
{"character": "m", "row": 0, "column": 1}
{"character": "p", "row": 0, "column": 2}
{"character": "o", "row": 0, "column": 3}
{"character": "r", "row": 0, "column": 4}
{"character": "t", "row": 0, "column": 5}
{"character": " ", "row": 0, "column": 6}
{"character": "M", "row": 0, "column": 7}
{"character": "a", "row": 0, "column": 8}
{"character": "t", "row": 0, "column": 9}
{"character": "h", "row": 0, "column": 10}
{"character": "l", "row": 0, "column": 11}
{"character": "i", "row": 0, "column": 12}
{"character": "b", "row": 0, "column": 13}
{"character": "t", "row": 2, "column": 0}
{"character": "h", "row": 2, "column": 1}
{"character": "e", "row": 2, "column": 2}
{"character": "o", "row": 2, "column": 3}
{"character": "r", "row": 2, "column": 4}
{"character": "e", "row": 2, "column": 5}
{"character": "m", "row": 2, "column": 6}
{"character": " ", "row": 2, "column": 7}
{"character": "e", "row": 2, "column": 8, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 21}}, "contents": {"value": "```lean\neq_bot_or_top {H : AddSubgroup ℚ} (hH : ∀ x ∈ H, 1 / x ∈ H) : H = ⊥ ∨ H = ⊤\n```", "kind": "markdown"}}
{"character": "q", "row": 2, "column": 9, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 21}}, "contents": {"value": "```lean\neq_bot_or_top {H : AddSubgroup ℚ} (hH : ∀ x ∈ H, 1 / x ∈ H) : H = ⊥ ∨ H = ⊤\n```", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 10, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 21}}, "contents": {"value": "```lean\neq_bot_or_top {H : AddSubgroup ℚ} (hH : ∀ x ∈ H, 1 / x ∈ H) : H = ⊥ ∨ H = ⊤\n```", "kind": "markdown"}}
{"character": "b", "row": 2, "column": 11, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 21}}, "contents": {"value": "```lean\neq_bot_or_top {H : AddSubgroup ℚ} (hH : ∀ x ∈ H, 1 / x ∈ H) : H = ⊥ ∨ H = ⊤\n```", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 12, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 21}}, "contents": {"value": "```lean\neq_bot_or_top {H : AddSubgroup ℚ} (hH : ∀ x ∈ H, 1 / x ∈ H) : H = ⊥ ∨ H = ⊤\n```", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 13, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 21}}, "contents": {"value": "```lean\neq_bot_or_top {H : AddSubgroup ℚ} (hH : ∀ x ∈ H, 1 / x ∈ H) : H = ⊥ ∨ H = ⊤\n```", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 14, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 21}}, "contents": {"value": "```lean\neq_bot_or_top {H : AddSubgroup ℚ} (hH : ∀ x ∈ H, 1 / x ∈ H) : H = ⊥ ∨ H = ⊤\n```", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 15, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 21}}, "contents": {"value": "```lean\neq_bot_or_top {H : AddSubgroup ℚ} (hH : ∀ x ∈ H, 1 / x ∈ H) : H = ⊥ ∨ H = ⊤\n```", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 16, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 21}}, "contents": {"value": "```lean\neq_bot_or_top {H : AddSubgroup ℚ} (hH : ∀ x ∈ H, 1 / x ∈ H) : H = ⊥ ∨ H = ⊤\n```", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 17, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 21}}, "contents": {"value": "```lean\neq_bot_or_top {H : AddSubgroup ℚ} (hH : ∀ x ∈ H, 1 / x ∈ H) : H = ⊥ ∨ H = ⊤\n```", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 18, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 21}}, "contents": {"value": "```lean\neq_bot_or_top {H : AddSubgroup ℚ} (hH : ∀ x ∈ H, 1 / x ∈ H) : H = ⊥ ∨ H = ⊤\n```", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 19, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 21}}, "contents": {"value": "```lean\neq_bot_or_top {H : AddSubgroup ℚ} (hH : ∀ x ∈ H, 1 / x ∈ H) : H = ⊥ ∨ H = ⊤\n```", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 20, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 21}}, "contents": {"value": "```lean\neq_bot_or_top {H : AddSubgroup ℚ} (hH : ∀ x ∈ H, 1 / x ∈ H) : H = ⊥ ∨ H = ⊤\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 21}
{"character": "{", "row": 2, "column": 22, "range": {"start": {"line": 2, "character": 22}, "end": {"line": 2, "character": 41}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": "H", "row": 2, "column": 23, "range": {"start": {"line": 2, "character": 23}, "end": {"line": 2, "character": 24}}, "contents": {"value": "```lean\nH : AddSubgroup ℚ\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 24}
{"character": ":", "row": 2, "column": 25, "range": {"start": {"line": 2, "character": 22}, "end": {"line": 2, "character": 41}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 26}
{"character": "A", "row": 2, "column": 27, "range": {"start": {"line": 2, "character": 27}, "end": {"line": 2, "character": 38}}, "contents": {"value": "```lean\nAddSubgroup.{u_3} (G : Type u_3) [AddGroup G] : Type u_3\n```\n***\nAn additive subgroup of an additive group `G` is a subset containing 0, closed\nunder addition and additive inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "d", "row": 2, "column": 28, "range": {"start": {"line": 2, "character": 27}, "end": {"line": 2, "character": 38}}, "contents": {"value": "```lean\nAddSubgroup.{u_3} (G : Type u_3) [AddGroup G] : Type u_3\n```\n***\nAn additive subgroup of an additive group `G` is a subset containing 0, closed\nunder addition and additive inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "d", "row": 2, "column": 29, "range": {"start": {"line": 2, "character": 27}, "end": {"line": 2, "character": 38}}, "contents": {"value": "```lean\nAddSubgroup.{u_3} (G : Type u_3) [AddGroup G] : Type u_3\n```\n***\nAn additive subgroup of an additive group `G` is a subset containing 0, closed\nunder addition and additive inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "S", "row": 2, "column": 30, "range": {"start": {"line": 2, "character": 27}, "end": {"line": 2, "character": 38}}, "contents": {"value": "```lean\nAddSubgroup.{u_3} (G : Type u_3) [AddGroup G] : Type u_3\n```\n***\nAn additive subgroup of an additive group `G` is a subset containing 0, closed\nunder addition and additive inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 31, "range": {"start": {"line": 2, "character": 27}, "end": {"line": 2, "character": 38}}, "contents": {"value": "```lean\nAddSubgroup.{u_3} (G : Type u_3) [AddGroup G] : Type u_3\n```\n***\nAn additive subgroup of an additive group `G` is a subset containing 0, closed\nunder addition and additive inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "b", "row": 2, "column": 32, "range": {"start": {"line": 2, "character": 27}, "end": {"line": 2, "character": 38}}, "contents": {"value": "```lean\nAddSubgroup.{u_3} (G : Type u_3) [AddGroup G] : Type u_3\n```\n***\nAn additive subgroup of an additive group `G` is a subset containing 0, closed\nunder addition and additive inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "g", "row": 2, "column": 33, "range": {"start": {"line": 2, "character": 27}, "end": {"line": 2, "character": 38}}, "contents": {"value": "```lean\nAddSubgroup.{u_3} (G : Type u_3) [AddGroup G] : Type u_3\n```\n***\nAn additive subgroup of an additive group `G` is a subset containing 0, closed\nunder addition and additive inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 34, "range": {"start": {"line": 2, "character": 27}, "end": {"line": 2, "character": 38}}, "contents": {"value": "```lean\nAddSubgroup.{u_3} (G : Type u_3) [AddGroup G] : Type u_3\n```\n***\nAn additive subgroup of an additive group `G` is a subset containing 0, closed\nunder addition and additive inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 35, "range": {"start": {"line": 2, "character": 27}, "end": {"line": 2, "character": 38}}, "contents": {"value": "```lean\nAddSubgroup.{u_3} (G : Type u_3) [AddGroup G] : Type u_3\n```\n***\nAn additive subgroup of an additive group `G` is a subset containing 0, closed\nunder addition and additive inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 36, "range": {"start": {"line": 2, "character": 27}, "end": {"line": 2, "character": 38}}, "contents": {"value": "```lean\nAddSubgroup.{u_3} (G : Type u_3) [AddGroup G] : Type u_3\n```\n***\nAn additive subgroup of an additive group `G` is a subset containing 0, closed\nunder addition and additive inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 37, "range": {"start": {"line": 2, "character": 27}, "end": {"line": 2, "character": 38}}, "contents": {"value": "```lean\nAddSubgroup.{u_3} (G : Type u_3) [AddGroup G] : Type u_3\n```\n***\nAn additive subgroup of an additive group `G` is a subset containing 0, closed\nunder addition and additive inverse. \n***\n*import Mathlib.Algebra.Group.Subgroup.Defs*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 38, "range": {"start": {"line": 2, "character": 27}, "end": {"line": 2, "character": 40}}, "contents": {"value": "```lean\nType\n```", "kind": "markdown"}}
{"character": "ℚ", "row": 2, "column": 39, "range": {"start": {"line": 2, "character": 39}, "end": {"line": 2, "character": 40}}, "contents": {"value": "```lean\nRat : Type\n```\n***\nRational numbers, implemented as a pair of integers `num / den` such that the\ndenominator is positive and the numerator and denominator are coprime.\n\n***\n*import Batteries.Data.Rat.Basic*", "kind": "markdown"}}
{"character": "}", "row": 2, "column": 40, "range": {"start": {"line": 2, "character": 22}, "end": {"line": 2, "character": 41}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 41}
{"character": "(", "row": 2, "column": 42, "range": {"start": {"line": 2, "character": 42}, "end": {"line": 2, "character": 67}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "h", "row": 2, "column": 43, "range": {"start": {"line": 2, "character": 43}, "end": {"line": 2, "character": 45}}, "contents": {"value": "```lean\nhH : ∀ x ∈ H, 1 / x ∈ H\n```", "kind": "markdown"}}
{"character": "H", "row": 2, "column": 44, "range": {"start": {"line": 2, "character": 43}, "end": {"line": 2, "character": 45}}, "contents": {"value": "```lean\nhH : ∀ x ∈ H, 1 / x ∈ H\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 45}
{"character": ":", "row": 2, "column": 46, "range": {"start": {"line": 2, "character": 42}, "end": {"line": 2, "character": 67}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 47}
{"character": "∀", "row": 2, "column": 48, "range": {"start": {"line": 2, "character": 48}, "end": {"line": 2, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\nThe notation `∀ x < 2, p x` is shorthand for `∀ x, x < 2 → p x`,\nand similarly for other binary operators.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 49, "range": {"start": {"line": 2, "character": 48}, "end": {"line": 2, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\nThe notation `∀ x < 2, p x` is shorthand for `∀ x, x < 2 → p x`,\nand similarly for other binary operators.\n", "kind": "markdown"}}
{"character": "x", "row": 2, "column": 50, "range": {"start": {"line": 2, "character": 50}, "end": {"line": 2, "character": 51}}, "contents": {"value": "```lean\nx : ℚ\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 51, "range": {"start": {"line": 2, "character": 48}, "end": {"line": 2, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\nThe notation `∀ x < 2, p x` is shorthand for `∀ x, x < 2 → p x`,\nand similarly for other binary operators.\n", "kind": "markdown"}}
{"character": "∈", "row": 2, "column": 52, "range": {"start": {"line": 2, "character": 52}, "end": {"line": 2, "character": 55}}, "contents": {"value": "Declare `∀ x ∈ y, ...` as syntax for `∀ x, x ∈ y → ...` and `∃ x ∈ y, ...` as syntax for\n`∃ x, x ∈ y ∧ ...` ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 53, "range": {"start": {"line": 2, "character": 48}, "end": {"line": 2, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\nThe notation `∀ x < 2, p x` is shorthand for `∀ x, x < 2 → p x`,\nand similarly for other binary operators.\n", "kind": "markdown"}}
{"character": "H", "row": 2, "column": 54, "range": {"start": {"line": 2, "character": 54}, "end": {"line": 2, "character": 55}}, "contents": {"value": "```lean\nH : AddSubgroup ℚ\n```", "kind": "markdown"}}
{"character": ",", "row": 2, "column": 55, "range": {"start": {"line": 2, "character": 48}, "end": {"line": 2, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\nThe notation `∀ x < 2, p x` is shorthand for `∀ x, x < 2 → p x`,\nand similarly for other binary operators.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 56, "range": {"start": {"line": 2, "character": 48}, "end": {"line": 2, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\nThe notation `∀ x < 2, p x` is shorthand for `∀ x, x < 2 → p x`,\nand similarly for other binary operators.\n", "kind": "markdown"}}
{"character": "1", "row": 2, "column": 57, "range": {"start": {"line": 2, "character": 57}, "end": {"line": 2, "character": 58}}, "contents": {"value": "```lean\n1 : ℚ\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 58, "range": {"start": {"line": 2, "character": 57}, "end": {"line": 2, "character": 62}}, "contents": {"value": "```lean\nℚ\n```\n***\n`a / b` computes the result of dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For most types like `Nat`, `Int`, `Rat`, `Real`, `a / 0` is defined to be `0`.\n* For `Nat`, `a / b` rounds downwards.\n* For `Int`, `a / b` rounds downwards if `b` is positive or upwards if `b` is negative.\n  It is implemented as `Int.ediv`, the unique function satisfying\n  `a % b + b * (a / b) = a` and `0 ≤ a % b < natAbs b` for `b ≠ 0`.\n  Other rounding conventions are available using the functions\n  `Int.fdiv` (floor rounding) and `Int.tdiv` (truncation rounding).\n* For `Float`, `a / 0` follows the IEEE 754 semantics for division,\n  usually resulting in `inf` or `nan`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `/` in identifiers is `div`.", "kind": "markdown"}}
{"character": "/", "row": 2, "column": 59, "range": {"start": {"line": 2, "character": 57}, "end": {"line": 2, "character": 62}}, "contents": {"value": "```lean\nℚ\n```\n***\n`a / b` computes the result of dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For most types like `Nat`, `Int`, `Rat`, `Real`, `a / 0` is defined to be `0`.\n* For `Nat`, `a / b` rounds downwards.\n* For `Int`, `a / b` rounds downwards if `b` is positive or upwards if `b` is negative.\n  It is implemented as `Int.ediv`, the unique function satisfying\n  `a % b + b * (a / b) = a` and `0 ≤ a % b < natAbs b` for `b ≠ 0`.\n  Other rounding conventions are available using the functions\n  `Int.fdiv` (floor rounding) and `Int.tdiv` (truncation rounding).\n* For `Float`, `a / 0` follows the IEEE 754 semantics for division,\n  usually resulting in `inf` or `nan`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `/` in identifiers is `div`.", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 60, "range": {"start": {"line": 2, "character": 57}, "end": {"line": 2, "character": 62}}, "contents": {"value": "```lean\nℚ\n```\n***\n`a / b` computes the result of dividing `a` by `b`.\nThe meaning of this notation is type-dependent.\n* For most types like `Nat`, `Int`, `Rat`, `Real`, `a / 0` is defined to be `0`.\n* For `Nat`, `a / b` rounds downwards.\n* For `Int`, `a / b` rounds downwards if `b` is positive or upwards if `b` is negative.\n  It is implemented as `Int.ediv`, the unique function satisfying\n  `a % b + b * (a / b) = a` and `0 ≤ a % b < natAbs b` for `b ≠ 0`.\n  Other rounding conventions are available using the functions\n  `Int.fdiv` (floor rounding) and `Int.tdiv` (truncation rounding).\n* For `Float`, `a / 0` follows the IEEE 754 semantics for division,\n  usually resulting in `inf` or `nan`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `/` in identifiers is `div`.", "kind": "markdown"}}
{"character": "x", "row": 2, "column": 61, "range": {"start": {"line": 2, "character": 61}, "end": {"line": 2, "character": 62}}, "contents": {"value": "```lean\nx : ℚ\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 62, "range": {"start": {"line": 2, "character": 57}, "end": {"line": 2, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\nThe membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "∈", "row": 2, "column": 63, "range": {"start": {"line": 2, "character": 57}, "end": {"line": 2, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\nThe membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 64, "range": {"start": {"line": 2, "character": 57}, "end": {"line": 2, "character": 66}}, "contents": {"value": "```lean\nProp\n```\n***\nThe membership relation `a ∈ s : Prop` where `a : α`, `s : γ`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∈` in identifiers is `mem`.", "kind": "markdown"}}
{"character": "H", "row": 2, "column": 65, "range": {"start": {"line": 2, "character": 65}, "end": {"line": 2, "character": 66}}, "contents": {"value": "```lean\nH : AddSubgroup ℚ\n```", "kind": "markdown"}}
{"character": ")", "row": 2, "column": 66, "range": {"start": {"line": 2, "character": 42}, "end": {"line": 2, "character": 67}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 67}
{"character": ":", "row": 2, "column": 68, "range": {"start": {"line": 2, "character": 22}, "end": {"line": 2, "character": 83}}, "contents": {"value": "`declSig` matches the signature of a declaration with required type: a list of binders and then `: type` ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 69}
{"character": "H", "row": 2, "column": 70, "range": {"start": {"line": 2, "character": 70}, "end": {"line": 2, "character": 71}}, "contents": {"value": "```lean\nH : AddSubgroup ℚ\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 71, "range": {"start": {"line": 2, "character": 70}, "end": {"line": 2, "character": 75}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "=", "row": 2, "column": 72, "range": {"start": {"line": 2, "character": 70}, "end": {"line": 2, "character": 75}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 73, "range": {"start": {"line": 2, "character": 70}, "end": {"line": 2, "character": 75}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "⊥", "row": 2, "column": 74, "range": {"start": {"line": 2, "character": 74}, "end": {"line": 2, "character": 75}}, "contents": {"value": "```lean\n⊥ : AddSubgroup ℚ\n```\n***\nThe bot (`⊥`, `\\bot`) element ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 75, "range": {"start": {"line": 2, "character": 70}, "end": {"line": 2, "character": 83}}, "contents": {"value": "```lean\nProp\n```\n***\n`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∨` in identifiers is `or`.", "kind": "markdown"}}
{"character": "∨", "row": 2, "column": 76, "range": {"start": {"line": 2, "character": 70}, "end": {"line": 2, "character": 83}}, "contents": {"value": "```lean\nProp\n```\n***\n`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∨` in identifiers is `or`.", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 77, "range": {"start": {"line": 2, "character": 70}, "end": {"line": 2, "character": 83}}, "contents": {"value": "```lean\nProp\n```\n***\n`Or a b`, or `a ∨ b`, is the disjunction of propositions. There are two\nconstructors for `Or`, called `Or.inl : a → a ∨ b` and `Or.inr : b → a ∨ b`,\nand you can use `match` or `cases` to destruct an `Or` assumption into the\ntwo cases.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∨` in identifiers is `or`.", "kind": "markdown"}}
{"character": "H", "row": 2, "column": 78, "range": {"start": {"line": 2, "character": 78}, "end": {"line": 2, "character": 79}}, "contents": {"value": "```lean\nH : AddSubgroup ℚ\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 79, "range": {"start": {"line": 2, "character": 78}, "end": {"line": 2, "character": 83}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "=", "row": 2, "column": 80, "range": {"start": {"line": 2, "character": 78}, "end": {"line": 2, "character": 83}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 81, "range": {"start": {"line": 2, "character": 78}, "end": {"line": 2, "character": 83}}, "contents": {"value": "```lean\nProp\n```\n***\nThe equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.", "kind": "markdown"}}
{"character": "⊤", "row": 2, "column": 82, "range": {"start": {"line": 2, "character": 82}, "end": {"line": 2, "character": 83}}, "contents": {"value": "```lean\n⊤ : AddSubgroup ℚ\n```\n***\nThe top (`⊤`, `\\top`) element ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 83}
{"character": ":", "row": 2, "column": 84}
{"character": "=", "row": 2, "column": 85}
{"character": " ", "row": 2, "column": 86}
{"character": "b", "row": 2, "column": 87, "range": {"start": {"line": 2, "character": 87}, "end": {"line": 2, "character": 95}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 88, "range": {"start": {"line": 2, "character": 87}, "end": {"line": 2, "character": 95}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 89, "range": {"start": {"line": 2, "character": 87}, "end": {"line": 2, "character": 95}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": "s", "row": 2, "column": 90, "range": {"start": {"line": 2, "character": 90}, "end": {"line": 2, "character": 95}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 91, "range": {"start": {"line": 2, "character": 90}, "end": {"line": 2, "character": 95}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 92, "range": {"start": {"line": 2, "character": 90}, "end": {"line": 2, "character": 95}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 93, "range": {"start": {"line": 2, "character": 90}, "end": {"line": 2, "character": 95}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 94, "range": {"start": {"line": 2, "character": 90}, "end": {"line": 2, "character": 95}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
