{"character": "i", "row": 0, "column": 0}
{"character": "m", "row": 0, "column": 1}
{"character": "p", "row": 0, "column": 2}
{"character": "o", "row": 0, "column": 3}
{"character": "r", "row": 0, "column": 4}
{"character": "t", "row": 0, "column": 5}
{"character": " ", "row": 0, "column": 6}
{"character": "M", "row": 0, "column": 7}
{"character": "a", "row": 0, "column": 8}
{"character": "t", "row": 0, "column": 9}
{"character": "h", "row": 0, "column": 10}
{"character": "l", "row": 0, "column": 11}
{"character": "i", "row": 0, "column": 12}
{"character": "b", "row": 0, "column": 13}
{"character": "t", "row": 2, "column": 0}
{"character": "h", "row": 2, "column": 1}
{"character": "e", "row": 2, "column": 2}
{"character": "o", "row": 2, "column": 3}
{"character": "r", "row": 2, "column": 4}
{"character": "e", "row": 2, "column": 5}
{"character": "m", "row": 2, "column": 6}
{"character": " ", "row": 2, "column": 7}
{"character": "i", "row": 2, "column": 8, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "s", "row": 2, "column": 9, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "U", "row": 2, "column": 10, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 11, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "i", "row": 2, "column": 12, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 13, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 14, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 15, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 16, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 17, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 18, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "a", "row": 2, "column": 19, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "d", "row": 2, "column": 20, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "d", "row": 2, "column": 21, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 22, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 23, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "f", "row": 2, "column": 24, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 25, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "i", "row": 2, "column": 26, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "s", "row": 2, "column": 27, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "N", "row": 2, "column": 28, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "i", "row": 2, "column": 29, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "l", "row": 2, "column": 30, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 31, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 32, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 33, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 34, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 35, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 36, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 37}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent.{u_1} {R : Type u_1} (x : R) [Ring R] (hx : IsNilpotent x) : IsUnit (1 + x)\n```", "kind": "markdown"}}
{"character": ".", "row": 2, "column": 37, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 43}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent : ∀ {R : Type u_1} (x : R) [inst : Ring R], IsNilpotent x → IsUnit (1 + x)\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "{", "row": 2, "column": 38, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 43}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent : ∀ {R : Type u_1} (x : R) [inst : Ring R], IsNilpotent x → IsUnit (1 + x)\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 39, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 43}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent : ∀ {R : Type u_1} (x : R) [inst : Ring R], IsNilpotent x → IsUnit (1 + x)\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 40, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 43}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent : ∀ {R : Type u_1} (x : R) [inst : Ring R], IsNilpotent x → IsUnit (1 + x)\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "1", "row": 2, "column": 41, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 43}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent : ∀ {R : Type u_1} (x : R) [inst : Ring R], IsNilpotent x → IsUnit (1 + x)\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": "}", "row": 2, "column": 42, "range": {"start": {"line": 2, "character": 8}, "end": {"line": 2, "character": 43}}, "contents": {"value": "```lean\nisUnit_one_add_of_isNilpotent : ∀ {R : Type u_1} (x : R) [inst : Ring R], IsNilpotent x → IsUnit (1 + x)\n```\n***\n`declId` matches `foo` or `foo.{u,v}`: an identifier possibly followed by a list of universe names ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 43}
{"character": "{", "row": 2, "column": 44, "range": {"start": {"line": 2, "character": 44}, "end": {"line": 2, "character": 58}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": "R", "row": 2, "column": 45, "range": {"start": {"line": 2, "character": 45}, "end": {"line": 2, "character": 46}}, "contents": {"value": "```lean\nR : Type u_1\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 46}
{"character": ":", "row": 2, "column": 47, "range": {"start": {"line": 2, "character": 44}, "end": {"line": 2, "character": 58}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 48}
{"character": "T", "row": 2, "column": 49, "range": {"start": {"line": 2, "character": 49}, "end": {"line": 2, "character": 57}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 50, "range": {"start": {"line": 2, "character": 49}, "end": {"line": 2, "character": 57}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 51, "range": {"start": {"line": 2, "character": 49}, "end": {"line": 2, "character": 57}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 52, "range": {"start": {"line": 2, "character": 49}, "end": {"line": 2, "character": 57}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 53, "range": {"start": {"line": 2, "character": 49}, "end": {"line": 2, "character": 57}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "u", "row": 2, "column": 54, "range": {"start": {"line": 2, "character": 49}, "end": {"line": 2, "character": 57}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "_", "row": 2, "column": 55, "range": {"start": {"line": 2, "character": 49}, "end": {"line": 2, "character": 57}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "1", "row": 2, "column": 56, "range": {"start": {"line": 2, "character": 49}, "end": {"line": 2, "character": 57}}, "contents": {"value": "A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. ", "kind": "markdown"}}
{"character": "}", "row": 2, "column": 57, "range": {"start": {"line": 2, "character": 44}, "end": {"line": 2, "character": 58}}, "contents": {"value": "Implicit binder, like `{x y : A}` or `{x y}`.\nIn regular applications, whenever all parameters before it have been specified,\nthen a `_` placeholder is automatically inserted for this parameter.\nImplicit parameters should be able to be determined from the other arguments and the return type\nby unification.\n\nIn `@` explicit mode, implicit binders behave like explicit binders.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 58}
{"character": "(", "row": 2, "column": 59, "range": {"start": {"line": 2, "character": 59}, "end": {"line": 2, "character": 66}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "x", "row": 2, "column": 60, "range": {"start": {"line": 2, "character": 60}, "end": {"line": 2, "character": 61}}, "contents": {"value": "```lean\nx : R\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 61}
{"character": ":", "row": 2, "column": 62, "range": {"start": {"line": 2, "character": 59}, "end": {"line": 2, "character": 66}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 63}
{"character": "R", "row": 2, "column": 64, "range": {"start": {"line": 2, "character": 64}, "end": {"line": 2, "character": 65}}, "contents": {"value": "```lean\nR : Type u_1\n```", "kind": "markdown"}}
{"character": ")", "row": 2, "column": 65, "range": {"start": {"line": 2, "character": 59}, "end": {"line": 2, "character": 66}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 66}
{"character": "[", "row": 2, "column": 67, "range": {"start": {"line": 2, "character": 67}, "end": {"line": 2, "character": 75}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": "R", "row": 2, "column": 68, "range": {"start": {"line": 2, "character": 68}, "end": {"line": 2, "character": 72}}, "contents": {"value": "```lean\nRing.{u} (R : Type u) : Type u\n```\n***\nA `Ring` is a `Semiring` with negation making it an additive group. \n***\n*import Mathlib.Algebra.Ring.Defs*", "kind": "markdown"}}
{"character": "i", "row": 2, "column": 69, "range": {"start": {"line": 2, "character": 68}, "end": {"line": 2, "character": 72}}, "contents": {"value": "```lean\nRing.{u} (R : Type u) : Type u\n```\n***\nA `Ring` is a `Semiring` with negation making it an additive group. \n***\n*import Mathlib.Algebra.Ring.Defs*", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 70, "range": {"start": {"line": 2, "character": 68}, "end": {"line": 2, "character": 72}}, "contents": {"value": "```lean\nRing.{u} (R : Type u) : Type u\n```\n***\nA `Ring` is a `Semiring` with negation making it an additive group. \n***\n*import Mathlib.Algebra.Ring.Defs*", "kind": "markdown"}}
{"character": "g", "row": 2, "column": 71, "range": {"start": {"line": 2, "character": 68}, "end": {"line": 2, "character": 72}}, "contents": {"value": "```lean\nRing.{u} (R : Type u) : Type u\n```\n***\nA `Ring` is a `Semiring` with negation making it an additive group. \n***\n*import Mathlib.Algebra.Ring.Defs*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 72, "range": {"start": {"line": 2, "character": 68}, "end": {"line": 2, "character": 74}}, "contents": {"value": "```lean\nType u_1\n```", "kind": "markdown"}}
{"character": "R", "row": 2, "column": 73, "range": {"start": {"line": 2, "character": 73}, "end": {"line": 2, "character": 74}}, "contents": {"value": "```lean\nR : Type u_1\n```", "kind": "markdown"}}
{"character": "]", "row": 2, "column": 74, "range": {"start": {"line": 2, "character": 67}, "end": {"line": 2, "character": 75}}, "contents": {"value": "Instance-implicit binder, like `[C]` or `[inst : C]`.\nIn regular applications without `@` explicit mode, it is automatically inserted\nand solved for by typeclass inference for the specified class `C`.\nIn `@` explicit mode, if `_` is used for an instance-implicit parameter, then it is still solved for by typeclass inference;\nuse `(_)` to inhibit this and have it be solved for by unification instead, like an implicit argument.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 75}
{"character": "(", "row": 2, "column": 76, "range": {"start": {"line": 2, "character": 76}, "end": {"line": 2, "character": 96}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": "h", "row": 2, "column": 77, "range": {"start": {"line": 2, "character": 77}, "end": {"line": 2, "character": 79}}, "contents": {"value": "```lean\nhx : IsNilpotent x\n```", "kind": "markdown"}}
{"character": "x", "row": 2, "column": 78, "range": {"start": {"line": 2, "character": 77}, "end": {"line": 2, "character": 79}}, "contents": {"value": "```lean\nhx : IsNilpotent x\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 79}
{"character": ":", "row": 2, "column": 80, "range": {"start": {"line": 2, "character": 76}, "end": {"line": 2, "character": 96}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 81}
{"character": "I", "row": 2, "column": 82, "range": {"start": {"line": 2, "character": 82}, "end": {"line": 2, "character": 93}}, "contents": {"value": "```lean\nIsNilpotent.{u_1} {R : Type u_1} [Zero R] [Pow R ℕ] (x : R) : Prop\n```\n***\nAn element is said to be nilpotent if some natural-number-power of it equals zero.\n\nNote that we require only the bare minimum assumptions for the definition to make sense. Even\n`MonoidWithZero` is too strong since nilpotency is important in the study of rings that are only\npower-associative. \n***\n*import Mathlib.RingTheory.Nilpotent.Defs*", "kind": "markdown"}}
{"character": "s", "row": 2, "column": 83, "range": {"start": {"line": 2, "character": 82}, "end": {"line": 2, "character": 93}}, "contents": {"value": "```lean\nIsNilpotent.{u_1} {R : Type u_1} [Zero R] [Pow R ℕ] (x : R) : Prop\n```\n***\nAn element is said to be nilpotent if some natural-number-power of it equals zero.\n\nNote that we require only the bare minimum assumptions for the definition to make sense. Even\n`MonoidWithZero` is too strong since nilpotency is important in the study of rings that are only\npower-associative. \n***\n*import Mathlib.RingTheory.Nilpotent.Defs*", "kind": "markdown"}}
{"character": "N", "row": 2, "column": 84, "range": {"start": {"line": 2, "character": 82}, "end": {"line": 2, "character": 93}}, "contents": {"value": "```lean\nIsNilpotent.{u_1} {R : Type u_1} [Zero R] [Pow R ℕ] (x : R) : Prop\n```\n***\nAn element is said to be nilpotent if some natural-number-power of it equals zero.\n\nNote that we require only the bare minimum assumptions for the definition to make sense. Even\n`MonoidWithZero` is too strong since nilpotency is important in the study of rings that are only\npower-associative. \n***\n*import Mathlib.RingTheory.Nilpotent.Defs*", "kind": "markdown"}}
{"character": "i", "row": 2, "column": 85, "range": {"start": {"line": 2, "character": 82}, "end": {"line": 2, "character": 93}}, "contents": {"value": "```lean\nIsNilpotent.{u_1} {R : Type u_1} [Zero R] [Pow R ℕ] (x : R) : Prop\n```\n***\nAn element is said to be nilpotent if some natural-number-power of it equals zero.\n\nNote that we require only the bare minimum assumptions for the definition to make sense. Even\n`MonoidWithZero` is too strong since nilpotency is important in the study of rings that are only\npower-associative. \n***\n*import Mathlib.RingTheory.Nilpotent.Defs*", "kind": "markdown"}}
{"character": "l", "row": 2, "column": 86, "range": {"start": {"line": 2, "character": 82}, "end": {"line": 2, "character": 93}}, "contents": {"value": "```lean\nIsNilpotent.{u_1} {R : Type u_1} [Zero R] [Pow R ℕ] (x : R) : Prop\n```\n***\nAn element is said to be nilpotent if some natural-number-power of it equals zero.\n\nNote that we require only the bare minimum assumptions for the definition to make sense. Even\n`MonoidWithZero` is too strong since nilpotency is important in the study of rings that are only\npower-associative. \n***\n*import Mathlib.RingTheory.Nilpotent.Defs*", "kind": "markdown"}}
{"character": "p", "row": 2, "column": 87, "range": {"start": {"line": 2, "character": 82}, "end": {"line": 2, "character": 93}}, "contents": {"value": "```lean\nIsNilpotent.{u_1} {R : Type u_1} [Zero R] [Pow R ℕ] (x : R) : Prop\n```\n***\nAn element is said to be nilpotent if some natural-number-power of it equals zero.\n\nNote that we require only the bare minimum assumptions for the definition to make sense. Even\n`MonoidWithZero` is too strong since nilpotency is important in the study of rings that are only\npower-associative. \n***\n*import Mathlib.RingTheory.Nilpotent.Defs*", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 88, "range": {"start": {"line": 2, "character": 82}, "end": {"line": 2, "character": 93}}, "contents": {"value": "```lean\nIsNilpotent.{u_1} {R : Type u_1} [Zero R] [Pow R ℕ] (x : R) : Prop\n```\n***\nAn element is said to be nilpotent if some natural-number-power of it equals zero.\n\nNote that we require only the bare minimum assumptions for the definition to make sense. Even\n`MonoidWithZero` is too strong since nilpotency is important in the study of rings that are only\npower-associative. \n***\n*import Mathlib.RingTheory.Nilpotent.Defs*", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 89, "range": {"start": {"line": 2, "character": 82}, "end": {"line": 2, "character": 93}}, "contents": {"value": "```lean\nIsNilpotent.{u_1} {R : Type u_1} [Zero R] [Pow R ℕ] (x : R) : Prop\n```\n***\nAn element is said to be nilpotent if some natural-number-power of it equals zero.\n\nNote that we require only the bare minimum assumptions for the definition to make sense. Even\n`MonoidWithZero` is too strong since nilpotency is important in the study of rings that are only\npower-associative. \n***\n*import Mathlib.RingTheory.Nilpotent.Defs*", "kind": "markdown"}}
{"character": "e", "row": 2, "column": 90, "range": {"start": {"line": 2, "character": 82}, "end": {"line": 2, "character": 93}}, "contents": {"value": "```lean\nIsNilpotent.{u_1} {R : Type u_1} [Zero R] [Pow R ℕ] (x : R) : Prop\n```\n***\nAn element is said to be nilpotent if some natural-number-power of it equals zero.\n\nNote that we require only the bare minimum assumptions for the definition to make sense. Even\n`MonoidWithZero` is too strong since nilpotency is important in the study of rings that are only\npower-associative. \n***\n*import Mathlib.RingTheory.Nilpotent.Defs*", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 91, "range": {"start": {"line": 2, "character": 82}, "end": {"line": 2, "character": 93}}, "contents": {"value": "```lean\nIsNilpotent.{u_1} {R : Type u_1} [Zero R] [Pow R ℕ] (x : R) : Prop\n```\n***\nAn element is said to be nilpotent if some natural-number-power of it equals zero.\n\nNote that we require only the bare minimum assumptions for the definition to make sense. Even\n`MonoidWithZero` is too strong since nilpotency is important in the study of rings that are only\npower-associative. \n***\n*import Mathlib.RingTheory.Nilpotent.Defs*", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 92, "range": {"start": {"line": 2, "character": 82}, "end": {"line": 2, "character": 93}}, "contents": {"value": "```lean\nIsNilpotent.{u_1} {R : Type u_1} [Zero R] [Pow R ℕ] (x : R) : Prop\n```\n***\nAn element is said to be nilpotent if some natural-number-power of it equals zero.\n\nNote that we require only the bare minimum assumptions for the definition to make sense. Even\n`MonoidWithZero` is too strong since nilpotency is important in the study of rings that are only\npower-associative. \n***\n*import Mathlib.RingTheory.Nilpotent.Defs*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 93, "range": {"start": {"line": 2, "character": 82}, "end": {"line": 2, "character": 95}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "x", "row": 2, "column": 94, "range": {"start": {"line": 2, "character": 94}, "end": {"line": 2, "character": 95}}, "contents": {"value": "```lean\nx : R\n```", "kind": "markdown"}}
{"character": ")", "row": 2, "column": 95, "range": {"start": {"line": 2, "character": 76}, "end": {"line": 2, "character": 96}}, "contents": {"value": "Explicit binder, like `(x y : A)` or `(x y)`.\nDefault values can be specified using `(x : A := v)` syntax, and tactics using `(x : A := by tac)`.\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 96}
{"character": ":", "row": 2, "column": 97, "range": {"start": {"line": 2, "character": 44}, "end": {"line": 2, "character": 113}}, "contents": {"value": "`declSig` matches the signature of a declaration with required type: a list of binders and then `: type` ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 98}
{"character": "I", "row": 2, "column": 99, "range": {"start": {"line": 2, "character": 99}, "end": {"line": 2, "character": 105}}, "contents": {"value": "```lean\nIsUnit.{u_1} {M : Type u_1} [Monoid M] (a : M) : Prop\n```\n***\nAn element `a : M` of a `Monoid` is a unit if it has a two-sided inverse.\nThe actual definition says that `a` is equal to some `u : Mˣ`, where\n`Mˣ` is a bundled version of `IsUnit`. \n***\n*import Mathlib.Algebra.Group.Units.Defs*", "kind": "markdown"}}
{"character": "s", "row": 2, "column": 100, "range": {"start": {"line": 2, "character": 99}, "end": {"line": 2, "character": 105}}, "contents": {"value": "```lean\nIsUnit.{u_1} {M : Type u_1} [Monoid M] (a : M) : Prop\n```\n***\nAn element `a : M` of a `Monoid` is a unit if it has a two-sided inverse.\nThe actual definition says that `a` is equal to some `u : Mˣ`, where\n`Mˣ` is a bundled version of `IsUnit`. \n***\n*import Mathlib.Algebra.Group.Units.Defs*", "kind": "markdown"}}
{"character": "U", "row": 2, "column": 101, "range": {"start": {"line": 2, "character": 99}, "end": {"line": 2, "character": 105}}, "contents": {"value": "```lean\nIsUnit.{u_1} {M : Type u_1} [Monoid M] (a : M) : Prop\n```\n***\nAn element `a : M` of a `Monoid` is a unit if it has a two-sided inverse.\nThe actual definition says that `a` is equal to some `u : Mˣ`, where\n`Mˣ` is a bundled version of `IsUnit`. \n***\n*import Mathlib.Algebra.Group.Units.Defs*", "kind": "markdown"}}
{"character": "n", "row": 2, "column": 102, "range": {"start": {"line": 2, "character": 99}, "end": {"line": 2, "character": 105}}, "contents": {"value": "```lean\nIsUnit.{u_1} {M : Type u_1} [Monoid M] (a : M) : Prop\n```\n***\nAn element `a : M` of a `Monoid` is a unit if it has a two-sided inverse.\nThe actual definition says that `a` is equal to some `u : Mˣ`, where\n`Mˣ` is a bundled version of `IsUnit`. \n***\n*import Mathlib.Algebra.Group.Units.Defs*", "kind": "markdown"}}
{"character": "i", "row": 2, "column": 103, "range": {"start": {"line": 2, "character": 99}, "end": {"line": 2, "character": 105}}, "contents": {"value": "```lean\nIsUnit.{u_1} {M : Type u_1} [Monoid M] (a : M) : Prop\n```\n***\nAn element `a : M` of a `Monoid` is a unit if it has a two-sided inverse.\nThe actual definition says that `a` is equal to some `u : Mˣ`, where\n`Mˣ` is a bundled version of `IsUnit`. \n***\n*import Mathlib.Algebra.Group.Units.Defs*", "kind": "markdown"}}
{"character": "t", "row": 2, "column": 104, "range": {"start": {"line": 2, "character": 99}, "end": {"line": 2, "character": 105}}, "contents": {"value": "```lean\nIsUnit.{u_1} {M : Type u_1} [Monoid M] (a : M) : Prop\n```\n***\nAn element `a : M` of a `Monoid` is a unit if it has a two-sided inverse.\nThe actual definition says that `a` is equal to some `u : Mˣ`, where\n`Mˣ` is a bundled version of `IsUnit`. \n***\n*import Mathlib.Algebra.Group.Units.Defs*", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 105, "range": {"start": {"line": 2, "character": 99}, "end": {"line": 2, "character": 113}}, "contents": {"value": "```lean\nProp\n```", "kind": "markdown"}}
{"character": "(", "row": 2, "column": 106, "range": {"start": {"line": 2, "character": 106}, "end": {"line": 2, "character": 113}}, "contents": {"value": "```lean\nR\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": "1", "row": 2, "column": 107, "range": {"start": {"line": 2, "character": 107}, "end": {"line": 2, "character": 108}}, "contents": {"value": "```lean\n1 : R\n```", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 108, "range": {"start": {"line": 2, "character": 107}, "end": {"line": 2, "character": 112}}, "contents": {"value": "```lean\nR\n```\n***\n`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.", "kind": "markdown"}}
{"character": "+", "row": 2, "column": 109, "range": {"start": {"line": 2, "character": 107}, "end": {"line": 2, "character": 112}}, "contents": {"value": "```lean\nR\n```\n***\n`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 110, "range": {"start": {"line": 2, "character": 107}, "end": {"line": 2, "character": 112}}, "contents": {"value": "```lean\nR\n```\n***\n`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.", "kind": "markdown"}}
{"character": "x", "row": 2, "column": 111, "range": {"start": {"line": 2, "character": 111}, "end": {"line": 2, "character": 112}}, "contents": {"value": "```lean\nx : R\n```", "kind": "markdown"}}
{"character": ")", "row": 2, "column": 112, "range": {"start": {"line": 2, "character": 106}, "end": {"line": 2, "character": 113}}, "contents": {"value": "```lean\nR\n```\n***\nParentheses, used for grouping expressions (e.g., `a * (b + c)`).\nCan also be used for creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n  - also applies to other parentheses-like notations such as `(·, 1)`\n", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 113}
{"character": ":", "row": 2, "column": 114}
{"character": "=", "row": 2, "column": 115}
{"character": " ", "row": 2, "column": 116}
{"character": "b", "row": 2, "column": 117, "range": {"start": {"line": 2, "character": 117}, "end": {"line": 2, "character": 125}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 118, "range": {"start": {"line": 2, "character": 117}, "end": {"line": 2, "character": 125}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": " ", "row": 2, "column": 119, "range": {"start": {"line": 2, "character": 117}, "end": {"line": 2, "character": 125}}, "contents": {"value": "`by tac` constructs a term of the expected type by running the tactic(s) `tac`. ", "kind": "markdown"}}
{"character": "s", "row": 2, "column": 120, "range": {"start": {"line": 2, "character": 120}, "end": {"line": 2, "character": 125}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "o", "row": 2, "column": 121, "range": {"start": {"line": 2, "character": 120}, "end": {"line": 2, "character": 125}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 122, "range": {"start": {"line": 2, "character": 120}, "end": {"line": 2, "character": 125}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "r", "row": 2, "column": 123, "range": {"start": {"line": 2, "character": 120}, "end": {"line": 2, "character": 125}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
{"character": "y", "row": 2, "column": 124, "range": {"start": {"line": 2, "character": 120}, "end": {"line": 2, "character": 125}}, "contents": {"value": "The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n", "kind": "markdown"}}
